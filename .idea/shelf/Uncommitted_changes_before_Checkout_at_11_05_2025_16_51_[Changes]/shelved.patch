Index: game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from asyncio import wait_for\r\nfrom os import remove\r\nfrom tkinter import *\r\nfrom tkinter import messagebox\r\nfrom tkinter import font\r\nfrom PIL import Image, ImageTk\r\nimport pygame\r\nimport math\r\nimport random\r\nfrom tkinter import ttk\r\nimport os\r\nimport ctypes\r\nimport pygame.transform\r\n\r\npygame.init()\r\n\r\npseudos = []\r\ndef lancement_pseudo(): #Fonction qui lance une page qui permet de récupérer les noms\r\n\r\n    pygame.init() # initialise pygame ( 2e fois pour sureté )\r\n    info = pygame.display.Info() #récupérer les informations sur la taille de l'ecran de l'utilisateur\r\n    WIDTH, HEIGHT = info.current_w, info.current_h #variables de largeur et de hauteur permettant d'adapter l'affichage à chaque utilisateur\r\n\r\n    # Création de la fenêtre pygame des pseudos\r\n    fenetre = pygame.display.set_mode((WIDTH, HEIGHT))  #ajuste la taille de la fenetre à celle de l'utilisateur\r\n    pygame.display.set_caption(\"pseudo\") #donne un titre à la page\r\n\r\n    # Chargement des images de fond\r\n    fond1 = pygame.transform.scale(pygame.image.load('pseudo2.png'), (WIDTH, HEIGHT)) #fond pour demande de pseudo du joueur 1\r\n    fond2 = pygame.transform.scale(pygame.image.load('pseudo1.png'), (WIDTH, HEIGHT)) #fond pour demande de pseudo du joueur 2\r\n\r\n    # Bouton ok\r\n    bouton_valider = pygame.image.load(\"ok.png\").convert_alpha() #\r\n    rect_bouton = bouton_valider.get_rect(topleft=(600, 500)) #recupere la portion de l'ecran associée au bouton ok pour permetre d'interagir avec\r\n\r\n    # Zone de saisie du pseudo ( rectangle blanc )\r\n    input_box = pygame.Rect(525, 400, 300, 50)\r\n    font = pygame.font.Font(None, 36)\r\n    texte = '' #initialise la variable texte qui sert à récupérer les pseudo\r\n\r\n    joueur_num = 1 # variable de test (pour l'affichage des pages et pour la position du pseudo dans la liste)\r\n\r\n\r\n    while True:\r\n        # Affiche le fond selon le joueur\r\n        fond = fond1 if joueur_num == 1 else fond2\r\n        fenetre.blit(fond, (0, 0))\r\n\r\n        # Affiche le bouton ok\r\n        fenetre.blit(bouton_valider, rect_bouton)\r\n\r\n        # Affiche la zone de saisie\r\n        pygame.draw.rect(fenetre, (255, 255, 255), input_box, 2)\r\n        texte_surface = font.render(texte, True, (255, 255, 255))\r\n        fenetre.blit(texte_surface, (input_box.x + 10, input_box.y + 10))\r\n\r\n        # Gestion des événements touches et clics\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                pygame.quit()\r\n                return None\r\n\r\n            if event.type == pygame.MOUSEBUTTONDOWN:\r\n                if rect_bouton.collidepoint(event.pos):\r\n                    pseudos.append(texte)\r\n                    texte = ''\r\n                    if joueur_num == 1:\r\n                        joueur_num = 2\r\n                    else:\r\n                        pygame.quit()\r\n                        return pseudos\r\n\r\n            if event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_RETURN:\r\n                    pseudos.append(texte)\r\n                    texte = ''\r\n                    if joueur_num == 1:\r\n                        joueur_num = 2\r\n                    else:\r\n                        pygame.quit()\r\n                        return pseudos\r\n                elif event.key == pygame.K_BACKSPACE:\r\n                    texte = texte[:-1]\r\n                else:\r\n                    texte += event.unicode\r\n\r\n        pygame.display.flip()\r\n\r\n\r\ndef gameover1():\r\n    info = pygame.display.Info()\r\n    WIDTH, HEIGHT = info.current_w, info.current_h\r\n    image = pygame.image.load(\"victoire_joueur1.png\")\r\n    image = pygame.transform.scale(image, (WIDTH, HEIGHT))\r\n\r\n    screen = pygame.display.get_surface()\r\n    screen.blit(image, (0, 0))\r\n    pygame.display.flip()\r\n    pygame.time.delay(5000)\r\n    pygame.quit()\r\ndef gameover2():\r\n    info = pygame.display.Info()\r\n    WIDTH, HEIGHT = info.current_w, info.current_h\r\n    image = pygame.image.load(\"victoire_joueur2.png\")\r\n    image = pygame.transform.scale(image, (WIDTH, HEIGHT))\r\n    screen = pygame.display.get_surface()\r\n    screen.blit(image, (0, 0))\r\n    pygame.display.flip()\r\n    pygame.time.delay(5000)\r\n    pygame.quit()\r\n\r\n\r\ndef lancement1():\r\n\r\n\r\n    fenetre.withdraw()  # Cache la fenêtre Tkinter\r\n    lancement_pseudo()\r\n    Afficher_consignes(1)\r\n    fenetre.deiconify()  # Réaffiche l'acceuil quand la fenetre de jeu se ferme\r\ndef lancement2():\r\n\r\n    fenetre.withdraw()  # Cache la fenêtre Tkinter\r\n\r\n    lancement_pseudo()\r\n    Afficher_consignes(2)\r\n    fenetre.deiconify()  # Réaffiche l'acceuil quand la fenetre de jeu se ferme\r\ndef lancement3():\r\n\r\n    fenetre.withdraw()\r\n\r\n    lancement_pseudo()\r\n    Afficher_consignes(3)\r\n    fenetre.deiconify()  # Réaffiche l'acceuil quand la fenetre de jeu se ferme\r\n\r\ndef jeu_debutant():\r\n    info = pygame.display.Info()\r\n    WIDTH, HEIGHT = info.current_w, info.current_h\r\n\r\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\r\n    pygame.display.set_caption(\"Astro Wars \")\r\n\r\n    # texte\r\n    big_font = pygame.font.SysFont('Arial', 40)\r\n    small_font = pygame.font.SysFont('Arial', 20)\r\n\r\n    # Génération des étoiles\r\n    NUM_STARS = 2000  # Nombre d'étoiles\r\n    stars = [(random.randint(0, WIDTH), random.randint(0, HEIGHT)) for _ in range(NUM_STARS)]\r\n\r\n    # Couleurs\r\n    BLACK = (0, 0, 0)\r\n    RED = (255, 0, 0)\r\n    YELLOW = (255, 255, 0)\r\n    BLUE = (0, 0, 255)\r\n    DARK_BLUE = (10, 10, 50)\r\n    WHITE = (255, 255, 255)\r\n    # Couleur Planetes\r\n\r\n    planet_images = [\r\n        pygame.image.load('planete_1.png'),\r\n        pygame.image.load('planete_2.png'),\r\n        pygame.image.load('planete_3.png'),\r\n        pygame.image.load('planete_4.png')\r\n    ]\r\n\r\n    planet_abimee = [\r\n        pygame.image.load('planete_1_2.png'),\r\n        pygame.image.load('planete_2_2.png'),\r\n        pygame.image.load('planete_3_2.png'),\r\n        pygame.image.load('planete_4_2.png')\r\n    ]\r\n\r\n    # Constantes physiques\r\n    G = 10\r\n    tir_vitesse = 10\r\n    # vitesse initiale des balles\r\n    vx = 10\r\n    vy = 0\r\n    vab = 10\r\n    vcd = 0\r\n    # score initiale\r\n    score1 = 0\r\n    score2 = 0\r\n\r\n    # carburant pour les vaisseaux\r\n    carburant0 = 100\r\n    carburant1 = 100\r\n\r\n    # Liste des planètes (coordonnées et masses)\r\n    planetes = []\r\n\r\n    # permet de mesurer la distance entre 2 planetes\r\n    def distance(p1, p2):\r\n        return math.sqrt((p1[\"x\"] - p2[\"x\"]) ** 2 + (p1[\"y\"] - p2[\"y\"]) ** 2)\r\n\r\n    # Permet de redimensionner les images des planetes\r\n\r\n    def resize_planet_image(image, masse):\r\n        size = int(masse / 4)\r\n        return pygame.transform.scale(image, (size, size))\r\n\r\n    # couleur des planetes\r\n    colors = [\r\n        (255, 0, 0),  # Rouge\r\n        (0, 255, 0),  # Vert\r\n        (0, 0, 255),  # Bleu\r\n        (255, 255, 0),  # Jaune\r\n        (0, 255, 255),  # Cyan\r\n        (255, 0, 255),  # Magenta\r\n        (128, 0, 0),  # Marron\r\n        (128, 128, 0),  # Olive\r\n        (0, 128, 0),  # Vert foncé\r\n        (128, 0, 128),  # Violet\r\n        (0, 128, 128),  # Bleu-vert\r\n        (0, 0, 128),  # Bleu marine\r\n        (255, 165, 0),  # Orange\r\n        (255, 192, 203),  # Rose\r\n        (75, 0, 130),  # Indigo\r\n        (139, 69, 19),  # Brun\r\n        (255, 215, 0),  # Or\r\n        (192, 192, 192),  # Argent\r\n        (169, 169, 169),  # Gris foncé\r\n        (0, 255, 127)  # Vert printemps\r\n    ]\r\n    pla = 7  # nombre de planetes generees\r\n    for i in range(pla):\r\n        while True:\r\n            x = random.randint(int(WIDTH * 0.45), int(WIDTH * 0.6))\r\n            y = random.randint(int(HEIGHT * 0.3), int(HEIGHT * 0.75))\r\n\r\n            pv = 6\r\n            masse = random.randint(250, 1500)\r\n\r\n            i = random.randint(0, len(planet_images) - 1)\r\n            image = resize_planet_image(planet_images[i], masse)\r\n            image_abimee = resize_planet_image(planet_abimee[i], masse)\r\n\r\n            new_planet = {\"x\": x,\"y\": y,\"masse\": masse,\"pv\": pv,\"compteur\": 0,\"image\": image, \"image_abimee\": image_abimee }\r\n            # Vérifier la distance avec toutes les planètes existantes\r\n            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for p in planetes):\r\n                planetes.append(new_planet)\r\n                break  # Sort de la boucle while quand une planète valide est trouvée\r\n\r\n    # Liste des projectiles\r\n    projectiles = []\r\n    explosions = []\r\n    # coordonnées d'apparition du point bleu\r\n    x = int(WIDTH * 0.15)  # Position X du joueur 0 (gauche)\r\n    y = int(HEIGHT / 2)  # Position Y du joueur 0 (milieu vertical)\r\n\r\n    ab = int(WIDTH * 0.85)  # Position X du joueur 1 (droite)\r\n    cd = int(HEIGHT / 2)  # Position Y du joueur 1 (milieu vertical)\r\n\r\n    object_image = pygame.image.load('vaisseau.png')\r\n    object_image = pygame.transform.scale(object_image, (50, 50))\r\n    missile_bleu = pygame.image.load('missile bleu.png')\r\n    missile_bleu = pygame.transform.scale(missile_bleu, (44, 44))\r\n    missile_rouge = pygame.image.load('missile rouge.png')\r\n    missile_rouge = pygame.transform.scale(missile_rouge, (44, 44))\r\n\r\n    explosion_frames = [pygame.image.load(f'explosion/frame_{i}.png') for i in range(6)]\r\n    explosion_sound = pygame.mixer.Sound(\"1917.mp3\")\r\n    explosion_sound.set_volume(0.2)  # Réglez le volume à 20% du volume maximal\r\n    missile_sound = pygame.mixer.Sound(\"missile.mp3\")\r\n    musique = pygame.mixer.Sound(\"04. Hacking Malfunction (Battle).mp3\")\r\n    musique.play(-1)\r\n\r\n    # Calcul des forces gravitationnelles\r\n    def calculeNewton(proj, planete):\r\n        dx = planete[\"x\"] - proj[\"x\"]\r\n        dy = planete[\"y\"] - proj[\"y\"]\r\n        distance_carre = dx ** 2 + dy ** 2\r\n\r\n        force_magnitude = G * planete[\"masse\"] / distance_carre\r\n        distance = math.sqrt(distance_carre)\r\n        return [force_magnitude * dx / distance, force_magnitude * dy / distance]\r\n\r\n    # Détection de collision entre missiles et vaisseaux\r\n    def collision_vaisseau(proj, vaisseau_x, vaisseau_y):\r\n        distance_proj_vaisseau = math.sqrt(\r\n            (proj[\"x\"] - (vaisseau_x + 25)) ** 2 + (proj[\"y\"] - (vaisseau_y + 25)) ** 2)\r\n        return distance_proj_vaisseau < 30  # Rayon de collision\r\n\r\n    preview_enabled = True\r\n    # Boucle principale\r\n    clock = pygame.time.Clock()\r\n    running = True\r\n    joueur_actuel = 0\r\n    vy = 1\r\n    vcd = 1\r\n    last_move_time = pygame.time.get_ticks()\r\n    angle = 0\r\n    angle2 = 180\r\n    speed = 2\r\n    show_preview = False\r\n\r\n    def simulate_trajectory(x, y, angle, vx):\r\n        points = []\r\n        ship_center_x = x + 25\r\n        ship_center_y = y + 25\r\n        temp_vx = vx * math.sin(math.radians(angle) - 80)\r\n        temp_vy = tir_vitesse * math.cos(math.radians(angle) - 80)\r\n        temp_x, temp_y = ship_center_x, ship_center_y\r\n        for _ in range(50):\r\n            accel_x, accel_y = 0, 0\r\n            for planete in planetes:\r\n                force = calculeNewton({\"x\": temp_x, \"y\": temp_y}, planete)\r\n                accel_x += force[0]\r\n                accel_y += force[1]\r\n            temp_vx += accel_x\r\n            temp_vy += accel_y\r\n            temp_x += temp_vx\r\n            temp_y += temp_vy\r\n            for planete in planetes:\r\n                if distance({\"x\": temp_x, \"y\": temp_y}, planete) < (planete[\"masse\"] / 10):\r\n                    return points  # Arrête la simulation si la trajectoire touche une planète\r\n            if temp_x < 0 or temp_x > WIDTH or temp_y < 0 or temp_y > HEIGHT:\r\n                break\r\n            points.append((int(temp_x), int(temp_y)))\r\n        return points\r\n\r\n    while running:\r\n        keys = pygame.key.get_pressed()\r\n        moved = False\r\n        if not projectiles:\r\n            if joueur_actuel == 0:\r\n                if carburant0 > 0:\r\n                    if 0 < y < HEIGHT and 0 < x < WIDTH // 3:\r\n                        if keys[pygame.K_UP]:\r\n                            if keys[pygame.K_r]:\r\n                                x += speed * math.cos(math.radians(angle)) * 2\r\n                                y -= speed * math.sin(math.radians(angle)) * 2\r\n                                carburant0 -= 0.5\r\n                            else:\r\n                                x += speed * math.cos(math.radians(angle))\r\n                                y -= speed * math.sin(math.radians(angle))\r\n                                carburant0 -= 0.1\r\n                            moved = True\r\n                        if keys[pygame.K_DOWN]:\r\n                            x -= speed * math.cos(math.radians(angle))\r\n                            y += speed * math.sin(math.radians(angle))\r\n                            moved = True\r\n                    else:\r\n                        if y <= 0:\r\n                            while y <= 0:\r\n                                y += 1\r\n                                moved = True\r\n                        if y >= HEIGHT:\r\n                            while y >= HEIGHT:\r\n                                y -= 1\r\n                                moved = True\r\n                        if x <= 0:\r\n                            while x <= 0:\r\n                                x += 1\r\n                                moved = True\r\n                        if x >= WIDTH // 3:\r\n                            while x >= WIDTH // 3:\r\n                                x -= 1\r\n                                moved = True\r\n                    if keys[pygame.K_RIGHT]:\r\n                        angle -= 1\r\n                        moved = True\r\n                    if keys[pygame.K_LEFT]:\r\n                        angle += 1\r\n                        moved = True\r\n                    if moved:\r\n                        last_move_time = pygame.time.get_ticks()\r\n                        show_preview = False\r\n                    elif pygame.time.get_ticks() - last_move_time > 200:\r\n                        show_preview = True\r\n\r\n            elif joueur_actuel == 1:\r\n                if carburant1 > 0:\r\n                    if 0 < cd < HEIGHT and (2 * WIDTH) // 3 < ab < WIDTH:\r\n                        if keys[pygame.K_UP]:\r\n                            if keys[pygame.K_r]:\r\n                                ab += speed * math.cos(math.radians(angle2)) * 2\r\n                                cd -= speed * math.sin(math.radians(angle2)) * 2\r\n                                carburant1 -= 0.5\r\n                            else:\r\n                                ab += speed * math.cos(math.radians(angle2))\r\n                                cd -= speed * math.sin(math.radians(angle2))\r\n                                carburant1 -= 0.1\r\n                            moved = True\r\n                        if keys[pygame.K_DOWN]:\r\n                            ab -= speed * math.cos(math.radians(angle2))\r\n                            cd += speed * math.sin(math.radians(angle2))\r\n                            moved = True\r\n                    else:\r\n                        if cd <= 0:\r\n                            while cd <= 0:\r\n                                cd += 1\r\n                                moved = True\r\n                        if cd >= HEIGHT:\r\n                            while cd >= HEIGHT:\r\n                                cd -= 1\r\n                                moved = True\r\n                        if ab <= (2 * WIDTH) // 3:\r\n                            while ab <= (2 * WIDTH) // 3:\r\n                                ab += 1\r\n                                moved = True\r\n                        if ab >= WIDTH:\r\n                            while ab >= WIDTH:\r\n                                ab -= 1\r\n                                moved = True\r\n                    if keys[pygame.K_RIGHT]:\r\n                        angle2 -= 1\r\n                        moved = True\r\n                    if keys[pygame.K_LEFT]:\r\n                        angle2 += 1\r\n                        moved = True\r\n                    if moved:\r\n                        last_move_time = pygame.time.get_ticks()\r\n                        show_preview = False\r\n                    elif pygame.time.get_ticks() - last_move_time > 200:\r\n                        show_preview = True\r\n\r\n        for event in pygame.event.get():\r\n\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n                pygame.quit()\r\n\r\n            if event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_t:\r\n                    planetes.clear()  # Supprime toutes les anciennes planètes\r\n                    pla = random.randint(4, 10)  # Nombre de nouvelles planètes\r\n                    for i in range(pla):\r\n                        while True:\r\n                            px = random.randint(320, 1660)\r\n                            py = random.randint(300, 780)\r\n                            masse = random.randint(250, 1500)\r\n                            a = random.randint(0, 255)\r\n                            b = random.randint(0, 255)\r\n                            c = random.randint(0, 255)\r\n                            color = (a, b, c)\r\n                            new_planet = {\"x\": px, \"y\": py, \"masse\": masse, \"color\": color}\r\n\r\n                            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for\r\n                                   p in\r\n                                   planetes):\r\n                                planetes.append(new_planet)\r\n                                break  # Ajoute la nouvelle planète et quitte la boucle\r\n                if event.key == pygame.K_SPACE:\r\n                    if joueur_actuel == 0:\r\n                        vX = vx * math.sin(math.radians(angle) - 80)\r\n                        vy = tir_vitesse * math.cos(math.radians(angle) - 80)\r\n\r\n                        # Calcul du nombre de missiles en fonction du carburant\r\n                        if carburant0 < 25:\r\n                            nb_missiles = 3\r\n                        elif carburant0 < 50:\r\n                            nb_missiles = 2\r\n                        else:\r\n                            nb_missiles = 1\r\n\r\n                        # Tir principal\r\n                        projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy, \"color\": BLUE})\r\n                        pygame.mixer.Sound.play(missile_sound)\r\n\r\n                        # Tirs supplémentaires si nb_missiles > 1\r\n                        if nb_missiles >= 2:\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        if nb_missiles == 3:\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 1, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 1, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        joueur_actuel = 1\r\n\r\n                    elif joueur_actuel == 1:\r\n                        vab = vx * math.sin(math.radians(angle2) - 80)\r\n                        vcd = tir_vitesse * math.cos(math.radians(angle2) - 80)\r\n\r\n                        # Déterminer le nombre de missiles en fonction du carburant\r\n                        if carburant1 < 25:\r\n                            nb_missiles2 = 3\r\n                        elif carburant1 < 50:\r\n                            nb_missiles2= 2\r\n                        else:\r\n                            nb_missiles2 = 1\r\n\r\n                        # Tir principal\r\n                        projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd, \"color\": RED})\r\n                        pygame.mixer.Sound.play(missile_sound)\r\n\r\n                        # Tirs supplémentaires si carburant faible\r\n                        if nb_missiles2 >= 2:\r\n                            projectiles.append( {\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        if nb_missiles2 == 3:\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 1, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 1, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n\r\n\r\n                        joueur_actuel = 0\r\n                if event.key == pygame.K_a:\r\n                    running = False\r\n                    pygame.quit()\r\n                if event.key == pygame.K_q:\r\n                    if joueur_actuel == 0:\r\n                        angle += 1\r\n                    else:\r\n                        angle2 += 1\r\n                if event.key == pygame.K_d:\r\n                    if joueur_actuel == 0:\r\n                        angle -= 1\r\n                    else:\r\n                        angle2 -= 1\r\n                if event.key == pygame.K_e:\r\n                    preview_enabled = not preview_enabled\r\n                if event.key == pygame.K_s and vx > 5:\r\n                    vx -= 1\r\n                if event.key == pygame.K_z and vx < 15:\r\n                    vx += 1\r\n\r\n        # Effacer l'écran\r\n        screen.fill(DARK_BLUE)  # Fond bleu foncé (galaxie)\r\n\r\n        # Dessin des étoiles\r\n        for star in stars:\r\n            pygame.draw.circle(screen, YELLOW, star, 1)  # Petits points jaunes\r\n\r\n        def dessiner_jauge_carburant(screen, x, y, largeur, hauteur, carburant):\r\n            # Calculer la largeur de la jauge en fonction du carburant restant\r\n            carburant_largeur = (carburant / 100) * largeur\r\n            # Dessiner le fond de la jauge (rouge)\r\n            pygame.draw.rect(screen, RED, (x, y, largeur, hauteur))\r\n            # Dessiner la jauge de carburant (bleue)\r\n            pygame.draw.rect(screen, BLUE, (x, y, carburant_largeur, hauteur))\r\n            # Dessiner la bordure de la jauge (noir)\r\n            pygame.draw.rect(screen, BLACK, (x, y, largeur, hauteur), 2)\r\n\r\n        largeur_jauge = int(WIDTH * 0.15)  # 15% de la largeur de l'écran\r\n        hauteur_jauge = 30\r\n        marge = 20\r\n\r\n        # Dessiner les jauges dynamiquement\r\n        # Joueur 1 (gauche)\r\n        dessiner_jauge_carburant(screen, marge, marge, largeur_jauge, hauteur_jauge, carburant0)\r\n\r\n        # Joueur 2 (droite)\r\n        dessiner_jauge_carburant(screen, WIDTH - largeur_jauge - marge, marge, largeur_jauge, hauteur_jauge, carburant1)\r\n\r\n        # Dessiner les planètes\r\n        for planete in planetes:\r\n            image_rect = planete[\"image\"].get_rect(center=(planete[\"x\"], planete[\"y\"]))\r\n            screen.blit(planete[\"image\"], image_rect.topleft)\r\n\r\n        # Dessiner la position initiale du projectile en bleu\r\n        rotated_image = pygame.transform.rotate(object_image, angle)\r\n        new_rect = rotated_image.get_rect(center=object_image.get_rect(topleft=(x, y)).center)\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n\r\n        rotated_image = pygame.transform.rotate(object_image, angle2)\r\n        new_rect = rotated_image.get_rect(center=object_image.get_rect(topleft=(ab, cd)).center)\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n\r\n        # Mettre à jour et dessiner les projectiles\r\n        for proj in projectiles:\r\n            accel_x, accel_y = 0, 0\r\n            collide = 0\r\n            for planete in planetes:  # permet de calculer pour chaque planete l'acceleration de la balle\r\n                force = calculeNewton(proj, planete)\r\n                accel_x += force[0]\r\n                accel_y += force[1]\r\n                collided = (math.sqrt((proj[\"x\"] - planete[\"x\"]) ** 2 + (proj[\"y\"] - planete[\"y\"]) ** 2) <= planete[\r\n                    \"masse\"] / 10)  # permet de calculer pour chaque planete les colisions avec les balles\r\n                if collided and collide == 0:\r\n                    # Réduction des points de vie\r\n                    planete[\"pv\"] -= 1\r\n                    if planete[\"pv\"] == 1:\r\n                        planete[\"image\"] = planete[\"image_abimee\"]\r\n                    elif planete[\"pv\"] <= 0:\r\n                        planetes.remove(planete)\r\n                    collide += 1\r\n                    pygame.mixer.Sound.play(explosion_sound)\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    projectiles.remove(proj)\r\n            off_screen = (proj[\"x\"] < 0 or proj[\"x\"] > WIDTH or proj[\"y\"] < 0 or proj[\r\n                \"y\"] > HEIGHT)  # verif si la balle est dans l'écran\r\n            if off_screen:\r\n                projectiles.remove(proj)  # suprime la balle si elle est hors de l'écran\r\n            # Mise à jour des vitesses et positions\r\n            proj[\"vx\"] += accel_x\r\n            proj[\"vy\"] += accel_y\r\n            proj[\"x\"] += proj[\"vx\"]\r\n            proj[\"y\"] += proj[\"vy\"]\r\n\r\n            # Dessiner le projectile\r\n            angle_proj = math.degrees(math.atan2(proj[\"vy\"], proj[\"vx\"]))\r\n            if proj[\"color\"] == BLUE:\r\n                rotated_missile = pygame.transform.rotate(missile_bleu, -angle_proj - 90)\r\n            else:\r\n                rotated_missile = pygame.transform.rotate(missile_rouge, -angle_proj - 90)\r\n            new_rect = rotated_missile.get_rect(center=(proj[\"x\"], proj[\"y\"]))\r\n            screen.blit(rotated_missile, new_rect.topleft)\r\n\r\n            # Vérifier les collisions des projectiles avec les vaisseaux\r\n            for proj in projectiles[:]:  # Copie de la liste pour éviter les erreurs de suppression\r\n                if proj[\"color\"] == RED and collision_vaisseau(proj, x, y):\r\n                    pygame.mixer.Sound.play(explosion_sound)  # Explosion du vaisseau bleu\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    score2 += 1\r\n                    if score1 == 5:\r\n                        gameover1()\r\n                        pygame.quit()\r\n                    projectiles.remove(proj)\r\n                elif proj[\"color\"] == BLUE and collision_vaisseau(proj, ab, cd):\r\n                    pygame.mixer.Sound.play(explosion_sound)  # Explosion du vaisseau rouge\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    score1 += 1\r\n                    if score2 == 5:\r\n                        gameover2()\r\n                        pygame.quit()\r\n                    projectiles.remove(proj)\r\n\r\n            # Affichage des explosions\r\n        for explosion in explosions:\r\n            frame_index = explosion[\"frame\"] // 5\r\n            if frame_index < len(explosion_frames):\r\n                screen.blit(explosion_frames[frame_index], (explosion[\"x\"] - 50, explosion[\"y\"] - 50))\r\n                explosion[\"frame\"] += 1\r\n            else:\r\n                explosions.remove(explosion)\r\n\r\n        # affiche puissance du tir\r\n        if joueur_actuel == 0:\r\n            # Affichage de la vitesse et de l'angle\r\n            txt = big_font.render(f'Vitesse: {round(vx, 2)} | Angle: {round(angle, 1) % 360}°', True, WHITE)\r\n\r\n            # Affichage du pseudo juste en dessous du texte de la jauge (ou de l'élément précédent)\r\n            txt_pseudo = big_font.render(f' Player1: {pseudos[0]}', True, WHITE)\r\n\r\n            screen.blit(txt_pseudo, (25, 120))  #Affichage du pseudo\r\n\r\n            # Affichage du texte de la vitesse et de l'angle à sa place\r\n            screen.blit(txt, (25, 85))\r\n\r\n        elif joueur_actuel == 1:\r\n            txt = big_font.render(f'Vitesse: {round(vx, 2)} | Angle: {round(angle2 - 180, 1) % 360}°', True, WHITE)\r\n            screen.blit(txt, (WIDTH - 425, 85))\r\n            txt_pseudo = big_font.render(f' Player2: {pseudos[1]}', True, WHITE)\r\n\r\n            screen.blit(txt_pseudo, (WIDTH - 425, 120))  # Affichage du pseudo\r\n        if joueur_actuel == 0:\r\n            if show_preview and preview_enabled:\r\n                trajectory = simulate_trajectory(x, y, angle, vx)\r\n                for point in trajectory:\r\n                    pygame.draw.circle(screen, WHITE, point, 2)\r\n        elif joueur_actuel == 1:\r\n            if show_preview and preview_enabled:\r\n                trajectory = simulate_trajectory(ab, cd, angle2, vx)\r\n                for point in trajectory:\r\n                    pygame.draw.circle(screen, WHITE, point, 2)\r\n\r\n        txt2 = big_font.render(f'{score1} | {score2}', True, WHITE)\r\n        score_rect = txt2.get_rect(center=(WIDTH // 2, 50))\r\n        screen.blit(txt2, score_rect)\r\n        # Mettre à jour l'affichage\r\n        pygame.display.flip()\r\n        clock.tick(60)\r\ndef jeu_intermediaire():\r\n    info = pygame.display.Info()\r\n    WIDTH, HEIGHT = info.current_w, info.current_h\r\n\r\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\r\n    pygame.display.set_caption(\"Astro Wars \")\r\n\r\n    # texte\r\n    big_font = pygame.font.SysFont('Arial', 40)\r\n    small_font = pygame.font.SysFont('Arial', 20)\r\n\r\n    # Génération des étoiles\r\n    NUM_STARS = 2000  # Nombre d'étoiles\r\n    stars = [(random.randint(0, WIDTH), random.randint(0, HEIGHT)) for _ in range(NUM_STARS)]\r\n\r\n    # Couleurs\r\n    BLACK = (0, 0, 0)\r\n    RED = (255, 0, 0)\r\n    YELLOW = (255, 255, 0)\r\n    BLUE = (0, 0, 255)\r\n    DARK_BLUE = (10, 10, 50)\r\n    WHITE = (255, 255, 255)\r\n    # Couleur Planetes\r\n\r\n    planet_images = [\r\n        pygame.image.load('planete_1.png'),\r\n        pygame.image.load('planete_2.png'),\r\n        pygame.image.load('planete_3.png'),\r\n        pygame.image.load('planete_4.png')\r\n    ]\r\n\r\n    planet_abimee = [\r\n        pygame.image.load('planete_1_2.png'),\r\n        pygame.image.load('planete_2_2.png'),\r\n        pygame.image.load('planete_3_2.png'),\r\n        pygame.image.load('planete_4_2.png')\r\n    ]\r\n\r\n    # Constantes physiques\r\n    G = 10\r\n    tir_vitesse = 10\r\n    # vitesse initiale des balles\r\n    vx = 10\r\n    vy = 0\r\n    vab = 10\r\n    vcd = 0\r\n    # score initiale\r\n    score1 = 0\r\n    score2 = 0\r\n\r\n    # carburant pour les vaisseaux\r\n    carburant0 = 100\r\n    carburant1 = 100\r\n\r\n    # Liste des planètes (coordonnées et masses)\r\n    planetes = []\r\n\r\n    # permet de mesurer la distance entre 2 planetes\r\n    def distance(p1, p2):\r\n        return math.sqrt((p1[\"x\"] - p2[\"x\"]) ** 2 + (p1[\"y\"] - p2[\"y\"]) ** 2)\r\n\r\n    # Permet de redimensionner les images des planetes\r\n\r\n    def resize_planet_image(image, masse):\r\n        size = int(masse / 4)\r\n        return pygame.transform.scale(image, (size, size))\r\n\r\n    # couleur des planetes\r\n    colors = [\r\n        (255, 0, 0),  # Rouge\r\n        (0, 255, 0),  # Vert\r\n        (0, 0, 255),  # Bleu\r\n        (255, 255, 0),  # Jaune\r\n        (0, 255, 255),  # Cyan\r\n        (255, 0, 255),  # Magenta\r\n        (128, 0, 0),  # Marron\r\n        (128, 128, 0),  # Olive\r\n        (0, 128, 0),  # Vert foncé\r\n        (128, 0, 128),  # Violet\r\n        (0, 128, 128),  # Bleu-vert\r\n        (0, 0, 128),  # Bleu marine\r\n        (255, 165, 0),  # Orange\r\n        (255, 192, 203),  # Rose\r\n        (75, 0, 130),  # Indigo\r\n        (139, 69, 19),  # Brun\r\n        (255, 215, 0),  # Or\r\n        (192, 192, 192),  # Argent\r\n        (169, 169, 169),  # Gris foncé\r\n        (0, 255, 127)  # Vert printemps\r\n    ]\r\n    pla = 3  # nombre de planetes generees\r\n    for i in range(pla):\r\n        while True:\r\n            x = random.randint(int(WIDTH * 0.45), int(WIDTH * 0.6))\r\n            y = random.randint(int(HEIGHT * 0.3), int(HEIGHT * 0.75))\r\n\r\n            pv = 6\r\n            masse = random.randint(250, 1500)\r\n\r\n            i = random.randint(0, len(planet_images) - 1)\r\n            image = resize_planet_image(planet_images[i], masse)\r\n            image_abimee = resize_planet_image(planet_abimee[i], masse)\r\n\r\n            new_planet = {\"x\": x,\"y\": y,\"masse\": masse,\"pv\": pv,\"compteur\": 0,\"image\": image, \"image_abimee\": image_abimee }\r\n            # Vérifier la distance avec toutes les planètes existantes\r\n            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for p in planetes):\r\n                planetes.append(new_planet)\r\n                break  # Sort de la boucle while quand une planète valide est trouvée\r\n\r\n    # Liste des projectiles\r\n    projectiles = []\r\n    explosions = []\r\n    # coordonnées d'apparition du point bleu\r\n    x = int(WIDTH * 0.15)  # Position X du joueur 0 (gauche)\r\n    y = int(HEIGHT / 2)  # Position Y du joueur 0 (milieu vertical)\r\n\r\n    ab = int(WIDTH * 0.85)  # Position X du joueur 1 (droite)\r\n    cd = int(HEIGHT / 2)  # Position Y du joueur 1 (milieu vertical)\r\n\r\n    object_image = pygame.image.load('vaisseau.png')\r\n    object_image = pygame.transform.scale(object_image, (50, 50))\r\n    missile_bleu = pygame.image.load('missile bleu.png')\r\n    missile_bleu = pygame.transform.scale(missile_bleu, (44, 44))\r\n    missile_rouge = pygame.image.load('missile rouge.png')\r\n    missile_rouge = pygame.transform.scale(missile_rouge, (44, 44))\r\n\r\n    explosion_frames = [pygame.image.load(f'explosion/frame_{i}.png') for i in range(6)]\r\n    explosion_sound = pygame.mixer.Sound(\"1917.mp3\")\r\n    explosion_sound.set_volume(0.2)  # Réglez le volume à 20% du volume maximal\r\n    missile_sound = pygame.mixer.Sound(\"missile.mp3\")\r\n    musique = pygame.mixer.Sound(\"04. Hacking Malfunction (Battle).mp3\")\r\n    musique.play(-1)\r\n\r\n    # Calcul des forces gravitationnelles\r\n    def calculeNewton(proj, planete):\r\n        dx = planete[\"x\"] - proj[\"x\"]\r\n        dy = planete[\"y\"] - proj[\"y\"]\r\n        distance_carre = dx ** 2 + dy ** 2\r\n\r\n        force_magnitude = G * planete[\"masse\"] / distance_carre\r\n        distance = math.sqrt(distance_carre)\r\n        return [force_magnitude * dx / distance, force_magnitude * dy / distance]\r\n\r\n    # Détection de collision entre missiles et vaisseaux\r\n    def collision_vaisseau(proj, vaisseau_x, vaisseau_y):\r\n        distance_proj_vaisseau = math.sqrt(\r\n            (proj[\"x\"] - (vaisseau_x + 25)) ** 2 + (proj[\"y\"] - (vaisseau_y + 25)) ** 2)\r\n        return distance_proj_vaisseau < 30  # Rayon de collision\r\n\r\n    preview_enabled = True\r\n    # Boucle principale\r\n    clock = pygame.time.Clock()\r\n    running = True\r\n    joueur_actuel = 0\r\n    vy = 1\r\n    vcd = 1\r\n    last_move_time = pygame.time.get_ticks()\r\n    angle = 0\r\n    angle2 = 180\r\n    speed = 2\r\n    show_preview = False\r\n\r\n    def simulate_trajectory(x, y, angle, vx):\r\n        points = []\r\n        ship_center_x = x + 25\r\n        ship_center_y = y + 25\r\n        temp_vx = vx * math.sin(math.radians(angle) - 80)\r\n        temp_vy = tir_vitesse * math.cos(math.radians(angle) - 80)\r\n        temp_x, temp_y = ship_center_x, ship_center_y\r\n        for _ in range(50):\r\n            accel_x, accel_y = 0, 0\r\n            for planete in planetes:\r\n                force = calculeNewton({\"x\": temp_x, \"y\": temp_y}, planete)\r\n                accel_x += force[0]\r\n                accel_y += force[1]\r\n            temp_vx += accel_x\r\n            temp_vy += accel_y\r\n            temp_x += temp_vx\r\n            temp_y += temp_vy\r\n            for planete in planetes:\r\n                if distance({\"x\": temp_x, \"y\": temp_y}, planete) < (planete[\"masse\"] / 10):\r\n                    return points  # Arrête la simulation si la trajectoire touche une planète\r\n            if temp_x < 0 or temp_x > WIDTH or temp_y < 0 or temp_y > HEIGHT:\r\n                break\r\n            points.append((int(temp_x), int(temp_y)))\r\n        return points\r\n\r\n    while running:\r\n        keys = pygame.key.get_pressed()\r\n        moved = False\r\n        if not projectiles:\r\n            if joueur_actuel == 0:\r\n                if carburant0 > 0:\r\n                    if 0 < y < HEIGHT and 0 < x < WIDTH // 3:\r\n                        if keys[pygame.K_UP]:\r\n                            if keys[pygame.K_r]:\r\n                                x += speed * math.cos(math.radians(angle)) * 2\r\n                                y -= speed * math.sin(math.radians(angle)) * 2\r\n                                carburant0 -= 0.5\r\n                            else:\r\n                                x += speed * math.cos(math.radians(angle))\r\n                                y -= speed * math.sin(math.radians(angle))\r\n                                carburant0 -= 0.1\r\n                            moved = True\r\n                        if keys[pygame.K_DOWN]:\r\n                            x -= speed * math.cos(math.radians(angle))\r\n                            y += speed * math.sin(math.radians(angle))\r\n                            moved = True\r\n                    else:\r\n                        if y <= 0:\r\n                            while y <= 0:\r\n                                y += 1\r\n                                moved = True\r\n                        if y >= HEIGHT:\r\n                            while y >= HEIGHT:\r\n                                y -= 1\r\n                                moved = True\r\n                        if x <= 0:\r\n                            while x <= 0:\r\n                                x += 1\r\n                                moved = True\r\n                        if x >= WIDTH // 3:\r\n                            while x >= WIDTH // 3:\r\n                                x -= 1\r\n                                moved = True\r\n                    if keys[pygame.K_RIGHT]:\r\n                        angle -= 1\r\n                        moved = True\r\n                    if keys[pygame.K_LEFT]:\r\n                        angle += 1\r\n                        moved = True\r\n                    if moved:\r\n                        last_move_time = pygame.time.get_ticks()\r\n                        show_preview = False\r\n                    elif pygame.time.get_ticks() - last_move_time > 200:\r\n                        show_preview = True\r\n\r\n            elif joueur_actuel == 1:\r\n                if carburant1 > 0:\r\n                    if 0 < cd < HEIGHT and (2 * WIDTH) // 3 < ab < WIDTH:\r\n                        if keys[pygame.K_UP]:\r\n                            if keys[pygame.K_r]:\r\n                                ab += speed * math.cos(math.radians(angle2)) * 2\r\n                                cd -= speed * math.sin(math.radians(angle2)) * 2\r\n                                carburant1 -= 0.5\r\n                            else:\r\n                                ab += speed * math.cos(math.radians(angle2))\r\n                                cd -= speed * math.sin(math.radians(angle2))\r\n                                carburant1 -= 0.1\r\n                            moved = True\r\n                        if keys[pygame.K_DOWN]:\r\n                            ab -= speed * math.cos(math.radians(angle2))\r\n                            cd += speed * math.sin(math.radians(angle2))\r\n                            moved = True\r\n                    else:\r\n                        if cd <= 0:\r\n                            while cd <= 0:\r\n                                cd += 1\r\n                                moved = True\r\n                        if cd >= HEIGHT:\r\n                            while cd >= HEIGHT:\r\n                                cd -= 1\r\n                                moved = True\r\n                        if ab <= (2 * WIDTH) // 3:\r\n                            while ab <= (2 * WIDTH) // 3:\r\n                                ab += 1\r\n                                moved = True\r\n                        if ab >= WIDTH:\r\n                            while ab >= WIDTH:\r\n                                ab -= 1\r\n                                moved = True\r\n                    if keys[pygame.K_RIGHT]:\r\n                        angle2 -= 1\r\n                        moved = True\r\n                    if keys[pygame.K_LEFT]:\r\n                        angle2 += 1\r\n                        moved = True\r\n                    if moved:\r\n                        last_move_time = pygame.time.get_ticks()\r\n                        show_preview = False\r\n                    elif pygame.time.get_ticks() - last_move_time > 200:\r\n                        show_preview = True\r\n\r\n        for event in pygame.event.get():\r\n\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n                pygame.quit()\r\n\r\n            if event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_t:\r\n                    planetes.clear()  # Supprime toutes les anciennes planètes\r\n                    pla = random.randint(4, 10)  # Nombre de nouvelles planètes\r\n                    for i in range(pla):\r\n                        while True:\r\n                            px = random.randint(320, 1660)\r\n                            py = random.randint(300, 780)\r\n                            masse = random.randint(250, 1500)\r\n                            a = random.randint(0, 255)\r\n                            b = random.randint(0, 255)\r\n                            c = random.randint(0, 255)\r\n                            color = (a, b, c)\r\n                            new_planet = {\"x\": px, \"y\": py, \"masse\": masse, \"color\": color}\r\n\r\n                            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for\r\n                                   p in\r\n                                   planetes):\r\n                                planetes.append(new_planet)\r\n                                break  # Ajoute la nouvelle planète et quitte la boucle\r\n                if event.key == pygame.K_SPACE:\r\n                    if joueur_actuel == 0:\r\n                        vX = vx * math.sin(math.radians(angle) - 80)\r\n                        vy = tir_vitesse * math.cos(math.radians(angle) - 80)\r\n\r\n                        # Calcul du nombre de missiles en fonction du carburant\r\n                        if carburant0 < 25:\r\n                            nb_missiles = 3\r\n                        elif carburant0 < 50:\r\n                            nb_missiles = 2\r\n                        else:\r\n                            nb_missiles = 1\r\n\r\n                        # Tir principal\r\n                        projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy, \"color\": BLUE})\r\n                        pygame.mixer.Sound.play(missile_sound)\r\n\r\n                        # Tirs supplémentaires si nb_missiles > 1\r\n                        if nb_missiles >= 2:\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        if nb_missiles == 3:\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 1, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 1, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        joueur_actuel = 1\r\n\r\n                    elif joueur_actuel == 1:\r\n                        vab = vx * math.sin(math.radians(angle2) - 80)\r\n                        vcd = tir_vitesse * math.cos(math.radians(angle2) - 80)\r\n\r\n                        # Déterminer le nombre de missiles en fonction du carburant\r\n                        if carburant1 < 25:\r\n                            nb_missiles2 = 3\r\n                        elif carburant1 < 50:\r\n                            nb_missiles2= 2\r\n                        else:\r\n                            nb_missiles2 = 1\r\n\r\n                        # Tir principal\r\n                        projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd, \"color\": RED})\r\n                        pygame.mixer.Sound.play(missile_sound)\r\n\r\n                        # Tirs supplémentaires si carburant faible\r\n                        if nb_missiles2 >= 2:\r\n                            projectiles.append( {\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        if nb_missiles2 == 3:\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 1, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 1, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n\r\n\r\n                        joueur_actuel = 0\r\n                if event.key == pygame.K_a:\r\n                    running = False\r\n                    pygame.quit()\r\n                if event.key == pygame.K_q:\r\n                    if joueur_actuel == 0:\r\n                        angle += 1\r\n                    else:\r\n                        angle2 += 1\r\n                if event.key == pygame.K_d:\r\n                    if joueur_actuel == 0:\r\n                        angle -= 1\r\n                    else:\r\n                        angle2 -= 1\r\n                if event.key == pygame.K_e:\r\n                    preview_enabled = not preview_enabled\r\n                if event.key == pygame.K_s and vx > 5:\r\n                    vx -= 1\r\n                if event.key == pygame.K_z and vx < 15:\r\n                    vx += 1\r\n\r\n        # Effacer l'écran\r\n        screen.fill(DARK_BLUE)  # Fond bleu foncé (galaxie)\r\n\r\n        # Dessin des étoiles\r\n        for star in stars:\r\n            pygame.draw.circle(screen, YELLOW, star, 1)  # Petits points jaunes\r\n\r\n        def dessiner_jauge_carburant(screen, x, y, largeur, hauteur, carburant):\r\n            # Calculer la largeur de la jauge en fonction du carburant restant\r\n            carburant_largeur = (carburant / 100) * largeur\r\n            # Dessiner le fond de la jauge (rouge)\r\n            pygame.draw.rect(screen, RED, (x, y, largeur, hauteur))\r\n            # Dessiner la jauge de carburant (bleue)\r\n            pygame.draw.rect(screen, BLUE, (x, y, carburant_largeur, hauteur))\r\n            # Dessiner la bordure de la jauge (noir)\r\n            pygame.draw.rect(screen, BLACK, (x, y, largeur, hauteur), 2)\r\n\r\n        largeur_jauge = int(WIDTH * 0.15)  # 15% de la largeur de l'écran\r\n        hauteur_jauge = 30\r\n        marge = 20\r\n\r\n        # Dessiner les jauges dynamiquement\r\n        # Joueur 1 (gauche)\r\n        dessiner_jauge_carburant(screen, marge, marge, largeur_jauge, hauteur_jauge, carburant0)\r\n\r\n        # Joueur 2 (droite)\r\n        dessiner_jauge_carburant(screen, WIDTH - largeur_jauge - marge, marge, largeur_jauge, hauteur_jauge, carburant1)\r\n\r\n        # Dessiner les planètes\r\n        for planete in planetes:\r\n            image_rect = planete[\"image\"].get_rect(center=(planete[\"x\"], planete[\"y\"]))\r\n            screen.blit(planete[\"image\"], image_rect.topleft)\r\n\r\n        # Dessiner la position initiale du projectile en bleu\r\n        rotated_image = pygame.transform.rotate(object_image, angle)\r\n        new_rect = rotated_image.get_rect(center=object_image.get_rect(topleft=(x, y)).center)\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n\r\n        rotated_image = pygame.transform.rotate(object_image, angle2)\r\n        new_rect = rotated_image.get_rect(center=object_image.get_rect(topleft=(ab, cd)).center)\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n\r\n        # Mettre à jour et dessiner les projectiles\r\n        for proj in projectiles:\r\n            accel_x, accel_y = 0, 0\r\n            collide = 0\r\n            for planete in planetes:  # permet de calculer pour chaque planete l'acceleration de la balle\r\n                force = calculeNewton(proj, planete)\r\n                accel_x += force[0]\r\n                accel_y += force[1]\r\n                collided = (math.sqrt((proj[\"x\"] - planete[\"x\"]) ** 2 + (proj[\"y\"] - planete[\"y\"]) ** 2) <= planete[\r\n                    \"masse\"] / 10)  # permet de calculer pour chaque planete les colisions avec les balles\r\n                if collided and collide == 0:\r\n                    # Réduction des points de vie\r\n                    planete[\"pv\"] -= 1\r\n                    if planete[\"pv\"] == 3:\r\n                        planete[\"image\"] = planete[\"image_abimee\"]\r\n                    elif planete[\"pv\"] <= 0:\r\n                        planetes.remove(planete)\r\n                    collide += 1\r\n                    pygame.mixer.Sound.play(explosion_sound)\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    projectiles.remove(proj)\r\n            off_screen = (proj[\"x\"] < 0 or proj[\"x\"] > WIDTH or proj[\"y\"] < 0 or proj[\r\n                \"y\"] > HEIGHT)  # verif si la balle est dans l'écran\r\n            if off_screen:\r\n                projectiles.remove(proj)  # suprime la balle si elle est hors de l'écran\r\n            # Mise à jour des vitesses et positions\r\n            proj[\"vx\"] += accel_x\r\n            proj[\"vy\"] += accel_y\r\n            proj[\"x\"] += proj[\"vx\"]\r\n            proj[\"y\"] += proj[\"vy\"]\r\n\r\n            # Dessiner le projectile\r\n            angle_proj = math.degrees(math.atan2(proj[\"vy\"], proj[\"vx\"]))\r\n            if proj[\"color\"] == BLUE:\r\n                rotated_missile = pygame.transform.rotate(missile_bleu, -angle_proj - 90)\r\n            else:\r\n                rotated_missile = pygame.transform.rotate(missile_rouge, -angle_proj - 90)\r\n            new_rect = rotated_missile.get_rect(center=(proj[\"x\"], proj[\"y\"]))\r\n            screen.blit(rotated_missile, new_rect.topleft)\r\n\r\n            # Vérifier les collisions des projectiles avec les vaisseaux\r\n            for proj in projectiles[:]:  # Copie de la liste pour éviter les erreurs de suppression\r\n                if proj[\"color\"] == RED and collision_vaisseau(proj, x, y):\r\n                    pygame.mixer.Sound.play(explosion_sound)  # Explosion du vaisseau bleu\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    score2 += 1\r\n                    if score1 == 5:\r\n                        gameover1()\r\n                        pygame.quit()\r\n                    projectiles.remove(proj)\r\n                elif proj[\"color\"] == BLUE and collision_vaisseau(proj, ab, cd):\r\n                    pygame.mixer.Sound.play(explosion_sound)  # Explosion du vaisseau rouge\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    score1 += 1\r\n                    if score2 == 5:\r\n                        gameover2()\r\n                        pygame.quit()\r\n                    projectiles.remove(proj)\r\n\r\n            # Affichage des explosions\r\n        for explosion in explosions:\r\n            frame_index = explosion[\"frame\"] // 5\r\n            if frame_index < len(explosion_frames):\r\n                screen.blit(explosion_frames[frame_index], (explosion[\"x\"] - 50, explosion[\"y\"] - 50))\r\n                explosion[\"frame\"] += 1\r\n            else:\r\n                explosions.remove(explosion)\r\n\r\n        # affiche puissance du tir\r\n        if joueur_actuel == 0:\r\n            # Affichage de la vitesse et de l'angle\r\n            txt = big_font.render(f'Vitesse: {round(vx, 2)} | Angle: {round(angle, 1) % 360}°', True, WHITE)\r\n\r\n            # Affichage du pseudo juste en dessous du texte de la jauge (ou de l'élément précédent)\r\n            txt_pseudo = big_font.render(f' Player1: {pseudos[0]}', True, WHITE)\r\n\r\n            screen.blit(txt_pseudo, (25, 120))  #Affichage du pseudo\r\n\r\n            # Affichage du texte de la vitesse et de l'angle à sa place\r\n            screen.blit(txt, (25, 85))\r\n\r\n        elif joueur_actuel == 1:\r\n            txt = big_font.render(f'Vitesse: {round(vx, 2)} | Angle: {round(angle2 - 180, 1) % 360}°', True, WHITE)\r\n            screen.blit(txt, (WIDTH - 425, 85))\r\n            txt_pseudo = big_font.render(f' Player2: {pseudos[1]}', True, WHITE)\r\n\r\n            screen.blit(txt_pseudo, (WIDTH - 425, 120))  # Affichage du pseudo\r\n        if joueur_actuel == 0:\r\n            if show_preview and preview_enabled:\r\n                trajectory = simulate_trajectory(x, y, angle, vx)\r\n                for point in trajectory:\r\n                    pygame.draw.circle(screen, WHITE, point, 2)\r\n        elif joueur_actuel == 1:\r\n            if show_preview and preview_enabled:\r\n                trajectory = simulate_trajectory(ab, cd, angle2, vx)\r\n                for point in trajectory:\r\n                    pygame.draw.circle(screen, WHITE, point, 2)\r\n\r\n        txt2 = big_font.render(f'{score1} | {score2}', True, WHITE)\r\n        score_rect = txt2.get_rect(center=(WIDTH // 2, 50))\r\n        screen.blit(txt2, score_rect)\r\n        # Mettre à jour l'affichage\r\n        pygame.display.flip()\r\n        clock.tick(60)\r\ndef jeu_avance():\r\n    import pygame\r\n    import math\r\n    import random\r\n    import pygame.transform\r\n\r\n    # Initialisation de Pygame\r\n    pygame.init()\r\n\r\n    # Captation de la résolution de l'écran afin d'adapter le jeu à toutes les résolutions\r\n    root = Tk()\r\n    screen_width = root.winfo_screenwidth() #capte la largeur de l'écran\r\n    screen_height = root.winfo_screenheight() #capte la hauteur de l'écran\r\n    root.destroy()\r\n    # Configuration de la fenêtre\r\n    WIDTH, HEIGHT = screen_width, screen_height\r\n    screen = pygame.display.set_mode((WIDTH, HEIGHT))\r\n    pygame.display.set_caption(\"Moteur physique\")\r\n    font_size = round(0.024 * WIDTH)\r\n    # texte\r\n    big_font = pygame.font.SysFont('Arial', font_size)\r\n    small_font = pygame.font.SysFont('Arial', font_size)\r\n\r\n    # Génération des étoiles\r\n    NUM_STARS = 2000  # Nombre d'étoiles\r\n    stars = [(random.randint(0, WIDTH), random.randint(0, HEIGHT)) for _ in range(NUM_STARS)]\r\n\r\n    # Couleurs\r\n    BLACK = (0, 0, 0)\r\n    RED = (255, 0, 0)\r\n    YELLOW = (255, 255, 0)\r\n    BLUE = (0, 0, 255)\r\n    DARK_BLUE = (10, 10, 50)\r\n    WHITE = (255, 255, 255)\r\n    # Couleur Planetes\r\n    planet_images = [\r\n        pygame.image.load('planete_1.png'),\r\n        pygame.image.load('planete_2.png'),\r\n        pygame.image.load('planete_3.png'),\r\n        pygame.image.load('planete_4.png')\r\n    ]\r\n    # Constantes physiques\r\n    G = 10\r\n    tir_vitesse = 10\r\n    # vitesse initiale des balles\r\n    vx = 10\r\n    vy = 0\r\n    vab = 10\r\n    vcd = 0\r\n    # score initiale\r\n    score1 = 5\r\n    score2 = 5\r\n\r\n    # Coordonnées de référence pour la génération des planètes via touche t\r\n    ref_x1, ref_y1 = 0.2*WIDTH,  0.2 * HEIGHT\r\n    ref_x2, ref_y2 = 0.8*WIDTH, 0.2 * HEIGHT\r\n\r\n    # carburant pour les vaisseaux\r\n    carburant0 = 100\r\n    carburant1 = 100\r\n\r\n    # Liste des planètes (coordonnées et masses)\r\n    planetes = []\r\n\r\n    # permet de mesurer la distance entre 2 planetes\r\n    def distance(p1, p2):\r\n        return math.sqrt((p1[\"x\"] - p2[\"x\"]) ** 2 + (p1[\"y\"] - p2[\"y\"]) ** 2)\r\n\r\n    # Permet de redimensionner les images des planetes\r\n\r\n    def resize_planet_image(image, masse):\r\n        size = int(masse / 4)\r\n        return pygame.transform.scale(image, (size, size))\r\n\r\n    # coordonnées d'apparition du vaisseau 1 puis 2\r\n    x = 0.04 * WIDTH\r\n    y = 0.04 * HEIGHT\r\n\r\n    ab = 0.8 * WIDTH\r\n    cd = 0.2 * HEIGHT\r\n\r\n    # Distance minimale entre une planète et les vaisseaux\r\n    DISTANCE_MINIMALE_VAISSEAUX = 200\r\n\r\n    # Génération des planètes\r\n    pla = random.randint(6, 10)  # Nombre de planètes\r\n    for i in range(pla):\r\n        while True:\r\n            gen_x = random.randint(0, WIDTH)\r\n            gen_y = random.randint(0, HEIGHT)\r\n            pv = random.randint(3, 5)\r\n            masse = random.randint(250, 1500)\r\n            image = random.choice(planet_images)\r\n            resized_image = resize_planet_image(image, masse)\r\n            new_planet = {\"x\": gen_x, \"y\": gen_y, \"masse\": masse, 'pv': pv,\r\n                          'image': resized_image}\r\n            # Vérifier la distance avec toutes les planètes existantes, les vaisseaux et les points de référence\r\n            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for p\r\n                   in planetes) and \\\r\n                    math.sqrt(\r\n                        (gen_x - ref_x1) ** 2 + (gen_y - ref_y1) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                    math.sqrt(\r\n                        (gen_x - ref_x2) ** 2 + (gen_y - ref_y2) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                    math.sqrt((gen_x - x) ** 2 + (gen_y - y) ** 2) > 50 and \\\r\n                    math.sqrt((gen_x - ab) ** 2 + (gen_y - cd) ** 2) > 50:\r\n                planetes.append(new_planet)\r\n                break  # Ajoute la nouvelle planète et quitte la boucle\r\n    # Liste des projectiles\r\n    projectiles = []\r\n    explosions = []\r\n\r\n    object_image = pygame.image.load('vaisseau.png')\r\n    object_image = pygame.transform.scale(object_image, (50, 50))\r\n    missile_bleu = pygame.image.load('missile bleu.png')\r\n    missile_bleu = pygame.transform.scale(missile_bleu, (44, 44))\r\n    missile_rouge = pygame.image.load('missile rouge.png')\r\n    missile_rouge = pygame.transform.scale(missile_rouge, (44, 44))\r\n\r\n    explosion_frames = [pygame.image.load(f'explosion/frame_{i}.png') for i in range(6)]\r\n    explosion_sound = pygame.mixer.Sound(\"1917.mp3\")\r\n    explosion_sound.set_volume(0.2)  # Réglez le volume à 20% du volume maximal\r\n    missile_sound = pygame.mixer.Sound(\"missile.mp3\")\r\n    musique = pygame.mixer.Sound(\"04. Hacking Malfunction (Battle).mp3\")\r\n    musique.play(-1)\r\n\r\n    # Calcul des forces gravitationnelles\r\n    def calculeNewton(proj, planete):\r\n        dx = planete[\"x\"] - proj[\"x\"]\r\n        dy = planete[\"y\"] - proj[\"y\"]\r\n        distance_carre = dx ** 2 + dy ** 2\r\n\r\n        force_magnitude = G * planete[\"masse\"] / distance_carre\r\n        distance = math.sqrt(distance_carre)\r\n        return [force_magnitude * dx / distance, force_magnitude * dy / distance]\r\n\r\n    # Détection de collision entre missiles et vaisseaux\r\n    def collision_vaisseau(proj, vaisseau_x, vaisseau_y):\r\n        distance_proj_vaisseau = math.sqrt((proj[\"x\"] - (vaisseau_x + 25)) ** 2 + (proj[\"y\"] - (vaisseau_y + 25)) ** 2)\r\n        return distance_proj_vaisseau < 30  # Rayon de collision\r\n\r\n    preview_enabled = True\r\n    # Boucle principale\r\n    clock = pygame.time.Clock()\r\n    running = True\r\n    joueur_actuel = 0\r\n    vy = 1\r\n    vcd = 1\r\n    last_move_time = pygame.time.get_ticks()\r\n    angle = 0\r\n    angle2 = 180\r\n    speed = 2\r\n    show_preview = False\r\n\r\n    def simulate_trajectory(x, y, angle, vx):\r\n        points = []\r\n        ship_center_x = x + 25\r\n        ship_center_y = y + 25\r\n        temp_vx = vx * math.sin(math.radians(angle) - 80)\r\n        temp_vy = tir_vitesse * math.cos(math.radians(angle) - 80)\r\n        temp_x, temp_y = ship_center_x, ship_center_y\r\n        for _ in range(50):\r\n            accel_x, accel_y = 0, 0\r\n            for planete in planetes:\r\n                force = calculeNewton({\"x\": temp_x, \"y\": temp_y}, planete)\r\n                accel_x += force[0]\r\n                accel_y += force[1]\r\n            temp_vx += accel_x\r\n            temp_vy += accel_y\r\n            temp_x += temp_vx\r\n            temp_y += temp_vy\r\n            for planete in planetes:\r\n                if distance({\"x\": temp_x, \"y\": temp_y}, planete) < (planete[\"masse\"] / 10):\r\n                    return points  # Arrête la simulation si la trajectoire touche une planète\r\n            if temp_x < 0 or temp_x > WIDTH or temp_y < 0 or temp_y > HEIGHT:\r\n                break\r\n            points.append((int(temp_x), int(temp_y)))\r\n        return points\r\n\r\n    while running:\r\n        keys = pygame.key.get_pressed()\r\n        moved = False\r\n        if not projectiles:\r\n            if joueur_actuel == 0:\r\n                if carburant0 > 0:\r\n                    if keys[pygame.K_UP]:\r\n                        if keys[pygame.K_r]:\r\n                            x += speed * math.cos(math.radians(angle)) * 2\r\n                            y -= speed * math.sin(math.radians(angle)) * 2\r\n                            carburant0 -= 0.5\r\n                        else:\r\n                            x += speed * math.cos(math.radians(angle))\r\n                            y -= speed * math.sin(math.radians(angle))\r\n                            carburant0 -= 0.1\r\n                    if keys[pygame.K_DOWN]:\r\n                        x -= speed * math.cos(math.radians(angle))\r\n                        y += speed * math.sin(math.radians(angle))\r\n                        carburant0 -= 0.1\r\n                if keys[pygame.K_RIGHT]:\r\n                    angle -= 1\r\n                if keys[pygame.K_LEFT]:\r\n                    angle += 1\r\n                if moved:\r\n                    last_move_time = pygame.time.get_ticks()\r\n                    show_preview = False\r\n                elif pygame.time.get_ticks() - last_move_time > 200:\r\n                    show_preview = True\r\n\r\n            if joueur_actuel == 1:\r\n                if carburant1 > 0:\r\n                    if keys[pygame.K_UP]:\r\n                        if keys[pygame.K_r]:\r\n                            ab += speed * math.cos(math.radians(angle2)) * 2\r\n                            cd -= speed * math.sin(math.radians(angle2)) * 2\r\n                            carburant1 -= 0.5\r\n                        else:\r\n                            ab += speed * math.cos(math.radians(angle2))\r\n                            cd -= speed * math.sin(math.radians(angle2))\r\n                            carburant1 -= 0.1\r\n                if keys[pygame.K_DOWN]:\r\n                    ab -= speed * math.cos(math.radians(angle2))\r\n                    cd += speed * math.sin(math.radians(angle2))\r\n                    carburant1 -= 0.1\r\n                if keys[pygame.K_RIGHT]:\r\n                    angle2 -= 1\r\n                if keys[pygame.K_LEFT]:\r\n                    angle2 += 1\r\n        if moved:\r\n            last_move_time = pygame.time.get_ticks()\r\n            show_preview = False\r\n        elif pygame.time.get_ticks() - last_move_time > 200:\r\n            show_preview = True\r\n\r\n        for event in pygame.event.get():\r\n\r\n            if event.type == pygame.QUIT:\r\n                running = False\r\n                pygame.quit()\r\n\r\n            if event.type == pygame.KEYDOWN:\r\n                if event.key == pygame.K_t:\r\n                    planetes.clear()  # Supprime toutes les anciennes planètes\r\n                    pla = random.randint(6, 10)  # Nombre de nouvelles planètes\r\n                    for i in range(pla):\r\n                        while True:\r\n                            gen_x = random.randint(0, WIDTH)\r\n                            gen_y = random.randint(0, HEIGHT)\r\n                            pv = random.randint(3, 5)\r\n                            masse = random.randint(250, 1500)\r\n                            image = random.choice(planet_images)\r\n                            resized_image = resize_planet_image(image, masse)\r\n                            new_planet = {\"x\": gen_x, \"y\": gen_y, \"masse\": masse, 'pv': pv,\r\n                                          'image': resized_image}\r\n                            # Vérifier la distance avec toutes les planètes existantes, les vaisseaux et les points de référence\r\n                            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for p\r\n                                   in planetes) and \\\r\n                                    math.sqrt(\r\n                                        (gen_x - ref_x1) ** 2 + (gen_y - ref_y1) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                                    math.sqrt(\r\n                                        (gen_x - ref_x2) ** 2 + (gen_y - ref_y2) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                                    math.sqrt((gen_x - x) ** 2 + (gen_y - y) ** 2) > 50 and \\\r\n                                    math.sqrt((gen_x - ab) ** 2 + (gen_y - cd) ** 2) > 50:\r\n                                planetes.append(new_planet)\r\n                                break  # Ajoute la nouvelle planète et quitte la boucle\r\n                if event.key == pygame.K_SPACE:\r\n                    if joueur_actuel == 0:\r\n                        vX = vx * math.sin(math.radians(angle) - 80)\r\n                        vy = tir_vitesse * math.cos(math.radians(angle) - 80)\r\n                        projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy, \"color\": BLUE})\r\n                        pygame.mixer.Sound.play(missile_sound)\r\n                        if keys[pygame.K_f]:\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        if keys[pygame.K_g]:\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 0.5, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy + 1, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": x + 25, \"y\": y + 25, \"vx\": vX, \"vy\": vy - 1, \"color\": BLUE})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        joueur_actuel = 1\r\n                        carburant0 = min(carburant0 + 5, 100)\r\n                    elif joueur_actuel == 1:\r\n                        vab = vx * math.sin(math.radians(angle2) - 80)\r\n                        vcd = tir_vitesse * math.cos(math.radians(angle2) - 80)\r\n                        projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd, \"color\": RED})\r\n                        pygame.mixer.Sound.play(missile_sound)\r\n                        if keys[pygame.K_f]:\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        if keys[pygame.K_g]:\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 1, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 1, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd + 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                            projectiles.append({\"x\": ab + 25, \"y\": cd + 25, \"vx\": vab, \"vy\": vcd - 0.5, \"color\": RED})\r\n                            pygame.mixer.Sound.play(missile_sound)\r\n                        joueur_actuel = 0\r\n                        carburant1 = min(carburant1 + 5, 100)\r\n                if event.key == pygame.K_a:\r\n                    running = False\r\n                    pygame.quit()\r\n                if event.key == pygame.K_q:\r\n                    if joueur_actuel == 0:\r\n                        angle += 1\r\n                    else:\r\n                        angle2 += 1\r\n                if event.key == pygame.K_d:\r\n                    if joueur_actuel == 0:\r\n                        angle -= 1\r\n                    else:\r\n                        angle2 -= 1\r\n                if event.key == pygame.K_e:\r\n                    preview_enabled = not preview_enabled\r\n                if event.key == pygame.K_s and vx > 5:\r\n                    vx -= 1\r\n                if event.key == pygame.K_z and vx < 15:\r\n                    vx += 1\r\n\r\n        # Effacer l'écran\r\n        screen.fill(DARK_BLUE)  # Fond bleu foncé (galaxie)\r\n\r\n        # Dessin des étoiles\r\n        for star in stars:\r\n            pygame.draw.circle(screen, YELLOW, star, 1)  # Petits points jaunes\r\n\r\n        def dessiner_jauge_carburant(screen, x, y, largeur, hauteur, carburant):\r\n            # Calculer la largeur de la jauge en fonction du carburant restant\r\n            carburant_largeur = (carburant / 100) * largeur\r\n            # Dessiner le fond de la jauge (rouge)\r\n            pygame.draw.rect(screen, RED, (x, y, largeur, hauteur))\r\n            # Dessiner la jauge de carburant (bleue)\r\n            pygame.draw.rect(screen, BLUE, (x, y, carburant_largeur, hauteur))\r\n            # Dessiner la bordure de la jauge (noir)\r\n            pygame.draw.rect(screen, BLACK, (x, y, largeur, hauteur), 2)\r\n\r\n        dessiner_jauge_carburant(screen, 0.01 * WIDTH, 0.04 * HEIGHT, 0.2 * WIDTH, 0.04 * HEIGHT, carburant0)\r\n        dessiner_jauge_carburant(screen, WIDTH - 0.21 * WIDTH, 0.04 * HEIGHT, 0.2 * WIDTH, 0.04 * HEIGHT, carburant1)\r\n\r\n        # Dessiner les planètes\r\n        for planete in planetes:\r\n            image_rect = planete[\"image\"].get_rect(center=(planete[\"x\"], planete[\"y\"]))\r\n            screen.blit(planete[\"image\"], image_rect.topleft)\r\n\r\n        # Dessiner la position initiale du projectile en bleu\r\n        rotated_image = pygame.transform.rotate(object_image, angle)\r\n        new_rect = rotated_image.get_rect(center=object_image.get_rect(topleft=(x, y)).center)\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n\r\n        rotated_image = pygame.transform.rotate(object_image, angle2)\r\n        new_rect = rotated_image.get_rect(center=object_image.get_rect(topleft=(ab, cd)).center)\r\n        screen.blit(rotated_image, new_rect.topleft)\r\n\r\n        # Mettre à jour et dessiner les projectiles\r\n        for proj in projectiles:\r\n            accel_x, accel_y = 0, 0\r\n            collide = 0\r\n            for planete in planetes:  # permet de calculer pour chaque planete l'acceleration de la balle\r\n                force = calculeNewton(proj, planete)\r\n                accel_x += force[0]\r\n                accel_y += force[1]\r\n                collided = (math.sqrt((proj[\"x\"] - planete[\"x\"]) ** 2 + (proj[\"y\"] - planete[\"y\"]) ** 2) <= planete[\r\n                    \"masse\"] / 10)  # permet de calculer pour chaque planete les colisions avec les balles\r\n                if collided and collide == 0:\r\n                    planete['pv'] -= 1\r\n                    if planete['pv'] <= 0:\r\n                        planetes.remove(planete)\r\n                    collide += 1\r\n                    pygame.mixer.Sound.play(explosion_sound)\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    projectiles.remove(proj)\r\n            off_screen = (proj[\"x\"] < 0 or proj[\"x\"] > WIDTH or proj[\"y\"] < 0 or proj[\r\n                \"y\"] > HEIGHT)  # verif si la balle est dans l'écran\r\n            if off_screen:\r\n                projectiles.remove(proj)  # suprime la balle si elle est hors de l'écran\r\n            # Mise à jour des vitesses et positions\r\n            proj[\"vx\"] += accel_x\r\n            proj[\"vy\"] += accel_y\r\n            proj[\"x\"] += proj[\"vx\"]\r\n            proj[\"y\"] += proj[\"vy\"]\r\n\r\n            # Dessiner le projectile\r\n            angle_proj = math.degrees(math.atan2(proj[\"vy\"], proj[\"vx\"]))\r\n            if proj[\"color\"] == BLUE:\r\n                rotated_missile = pygame.transform.rotate(missile_bleu, -angle_proj - 90)\r\n            else:\r\n                rotated_missile = pygame.transform.rotate(missile_rouge, -angle_proj - 90)\r\n            new_rect = rotated_missile.get_rect(center=(proj[\"x\"], proj[\"y\"]))\r\n            screen.blit(rotated_missile, new_rect.topleft)\r\n\r\n            # Vérifier les collisions des projectiles avec les vaisseaux\r\n            for proj in projectiles[:]:  # Copie de la liste pour éviter les erreurs de suppression\r\n                if proj[\"color\"] == RED and collision_vaisseau(proj, x, y):\r\n                    pygame.mixer.Sound.play(explosion_sound)  # Explosion du vaisseau bleu\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    score1 -= 1\r\n                    planetes.clear()  # Supprime toutes les anciennes planètes\r\n                    pla = random.randint(6, 10)  # Nombre de nouvelles planètes\r\n                    for i in range(pla):\r\n                        while True:\r\n                            gen_x = random.randint(0, WIDTH)\r\n                            gen_y = random.randint(0, HEIGHT)\r\n                            pv = random.randint(3, 5)\r\n                            masse = random.randint(250, 1500)\r\n                            image = random.choice(planet_images)\r\n                            resized_image = resize_planet_image(image, masse)\r\n                            new_planet = {\"x\": gen_x, \"y\": gen_y, \"masse\": masse, 'pv': pv,\r\n                                          'image': resized_image}\r\n                            # Vérifier la distance avec toutes les planètes existantes, les vaisseaux et les points de référence\r\n                            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for p\r\n                                   in planetes) and \\\r\n                                    math.sqrt(\r\n                                        (gen_x - ref_x1) ** 2 + (gen_y - ref_y1) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                                    math.sqrt(\r\n                                        (gen_x - ref_x2) ** 2 + (gen_y - ref_y2) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                                    math.sqrt((gen_x - x) ** 2 + (gen_y - y) ** 2) > 50 and \\\r\n                                    math.sqrt((gen_x - ab) ** 2 + (gen_y - cd) ** 2) > 50:\r\n                                planetes.append(new_planet)\r\n                                break  # Ajoute la nouvelle planète et quitte la boucle\r\n                    if score1 == 0:\r\n                        pygame.quit()\r\n                    projectiles.remove(proj)\r\n                elif proj[\"color\"] == BLUE and collision_vaisseau(proj, ab, cd):\r\n                    pygame.mixer.Sound.play(explosion_sound)  # Explosion du vaisseau rouge\r\n                    explosions.append({\"x\": proj[\"x\"], \"y\": proj[\"y\"], \"frame\": 0})\r\n                    score2 -= 1\r\n                    planetes.clear()  # Supprime toutes les anciennes planètes\r\n                    pla = random.randint(6, 10)  # Nombre de nouvelles planètes\r\n                    planetes.clear()  # Supprime toutes les anciennes planètes\r\n                    pla = random.randint(6, 10)  # Nombre de nouvelles planètes\r\n                    for i in range(pla):\r\n                        while True:\r\n                            gen_x = random.randint(0, WIDTH)\r\n                            gen_y = random.randint(0, HEIGHT)\r\n                            pv = random.randint(3, 5)\r\n                            masse = random.randint(250, 1500)\r\n                            image = random.choice(planet_images)\r\n                            resized_image = resize_planet_image(image, masse)\r\n                            new_planet = {\"x\": gen_x, \"y\": gen_y, \"masse\": masse, 'pv': pv,\r\n                                          'image': resized_image}\r\n                            # Vérifier la distance avec toutes les planètes existantes, les vaisseaux et les points de référence\r\n                            if all(distance(new_planet, p) > ((p[\"masse\"] / 10 + new_planet[\"masse\"] / 10) + 30) for p\r\n                                   in planetes) and \\\r\n                                    math.sqrt(\r\n                                        (gen_x - ref_x1) ** 2 + (gen_y - ref_y1) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                                    math.sqrt(\r\n                                        (gen_x - ref_x2) ** 2 + (gen_y - ref_y2) ** 2) > DISTANCE_MINIMALE_VAISSEAUX and \\\r\n                                    math.sqrt((gen_x - x) ** 2 + (gen_y - y) ** 2) > 50 and \\\r\n                                    math.sqrt((gen_x - ab) ** 2 + (gen_y - cd) ** 2) > 50:\r\n                                planetes.append(new_planet)\r\n                                break  # Ajoute la nouvelle planète et quitte la boucle\r\n                    if score2 == 0:\r\n                        pygame.quit()\r\n                    projectiles.remove(proj)\r\n\r\n            # Affichage des explosions\r\n        for explosion in explosions:\r\n            frame_index = explosion[\"frame\"] // 5\r\n            if frame_index < len(explosion_frames):\r\n                screen.blit(explosion_frames[frame_index], (explosion[\"x\"] - 50, explosion[\"y\"] - 50))\r\n                explosion[\"frame\"] += 1\r\n            else:\r\n                explosions.remove(explosion)\r\n\r\n        # affiche puissance du tir\r\n        if joueur_actuel == 0:\r\n            txt = big_font.render(f'Vitesse: {round(vx, 2)} | Angle: {round(angle, 1) % 360}°', True, WHITE)\r\n            screen.blit(txt, (0.016 * WIDTH, 0.04 * HEIGHT))\r\n        elif joueur_actuel == 1:\r\n            txt = big_font.render(f'Vitesse: {round(vx, 2)} | Angle: {round(angle2 - 180, 1) % 360}°', True, WHITE)\r\n            screen.blit(txt, (0.795 * WIDTH, 0.04 * HEIGHT))\r\n        if joueur_actuel == 0:\r\n            if show_preview and preview_enabled:\r\n                trajectory = simulate_trajectory(x, y, angle, vx)\r\n                for point in trajectory:\r\n                    pygame.draw.circle(screen, WHITE, point, 2)\r\n        elif joueur_actuel == 1:\r\n            if show_preview and preview_enabled:\r\n                trajectory = simulate_trajectory(ab, cd, angle2, vx)\r\n                for point in trajectory:\r\n                    pygame.draw.circle(screen, WHITE, point, 2)\r\n\r\n        txt2 = big_font.render(f'{score1} | {score2}', True, WHITE)\r\n        screen.blit(txt2, (0.4 * WIDTH, 0.04 * HEIGHT))\r\n        # Mettre à jour l'affichage\r\n        pygame.display.flip()\r\n        clock.tick(60)\r\ndef Afficher_consignes(niveau):\r\n    pygame.init()  # Initialisation de Pygame\r\n\r\n    # Récupère la taille de l'écran de l'utilisateur\r\n    info = pygame.display.Info()\r\n    largeur, hauteur = info.current_w, info.current_h\r\n\r\n    # Crée une fenêtre redimensionnable\r\n    fenetre = pygame.display.set_mode((largeur, hauteur), pygame.RESIZABLE)\r\n    pygame.display.set_caption(\"Consignes\")\r\n\r\n    # Chargement et mise à l'échelle des images de fond\r\n    fond1 = pygame.transform.scale(pygame.image.load(\"consigne1.png\").convert(), (largeur, hauteur))\r\n    fond2 = pygame.transform.scale(pygame.image.load(\"consigne2.png\").convert(), (largeur, hauteur))\r\n\r\n    # Chargement des boutons avec transparence\r\n    bouton_ok = pygame.image.load(\"ok.png\").convert_alpha()\r\n    rect_ok = bouton_ok.get_rect(topleft=(600, 500))\r\n\r\n    bouton_jouer = pygame.image.load(\"jouer.png\").convert_alpha()\r\n    rect_jouer = bouton_jouer.get_rect(topleft=(600, 500))\r\n\r\n    affichage_etape = 1  # Étape 1 : affichage du premier fond\r\n    en_cours = True\r\n\r\n    while en_cours:\r\n        fenetre.fill((0, 0, 0))  # Nettoie l'écran\r\n        taille_fenetre = fenetre.get_size()\r\n\r\n        # Affiche le bon fond et bouton selon l'étape\r\n        if affichage_etape == 1:\r\n            fond = fond1\r\n            bouton = bouton_ok\r\n            rect = rect_ok\r\n        else:\r\n            fond = fond2\r\n            bouton = bouton_jouer\r\n            rect = rect_jouer\r\n\r\n        # Redimensionne si la fenêtre a changé de taille\r\n        if taille_fenetre != fond.get_size():\r\n            fond_affiche = pygame.transform.scale(fond, taille_fenetre)\r\n        else:\r\n            fond_affiche = fond\r\n\r\n        # Affiche le fond et le bouton\r\n        fenetre.blit(fond_affiche, (0, 0))\r\n        fenetre.blit(bouton, rect)\r\n\r\n        # Gestion des événements\r\n        for event in pygame.event.get():\r\n            if event.type == pygame.QUIT:\r\n                en_cours = False\r\n\r\n            elif event.type == pygame.VIDEORESIZE:\r\n                # Met à jour la fenêtre à la nouvelle taille\r\n                fenetre = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)\r\n\r\n            elif event.type == pygame.MOUSEBUTTONDOWN:\r\n                if rect.collidepoint(event.pos):\r\n                    if affichage_etape == 1:\r\n                        affichage_etape = 2  # Passe à l'étape suivante\r\n                    else:\r\n\r\n                        if niveau == 1:\r\n                            jeu_debutant()\r\n                        if niveau == 2:\r\n                            jeu_intermediaire()\r\n                        if niveau == 3:\r\n                            jeu_avance()\r\n\r\n                        en_cours = False\r\n\r\n        pygame.display.flip()  # Rafraîchit l'écran\r\n\r\n    pygame.quit()  # Ferme proprement Pygame\r\ndef fctmenu():\r\n    pygame.init()\r\n\r\n    #Canevas qui contient la fenetre de menu\r\n    canevas = Canvas(fenetre, borderwidth=0, highlightthickness=0, width=800, height=600, bg=\"#322432\")\r\n    canevas.create_image(400, 300, image=fond_menu)\r\n\r\n    #boutons du menu\r\n\r\n    bouton_quitter2 = Button(canevas, image=croix, borderwidth=0, highlightthickness=0, bg=\"#322432\", command=canevas.destroy)\r\n    bouton_quitter2.place(x=775, y=4)\r\n\r\n\r\n    # Variables des paramètres\r\n    visee_auto = BooleanVar(value=False)\r\n    niveau_sonore = IntVar(value=100)\r\n    pv = IntVar(value=100)\r\n    tirs_par_joueur = IntVar(value=2)\r\n    degats_par_tir = IntVar(value=10)\r\n    niveau_selectionne = StringVar(value=\"Débutant\")\r\n\r\n    niveaux = [\"Débutant\", \"Intermédiaire\", \"Avancé\", \"Expert\"]\r\n    visee=0\r\n    # Fonction Toggle Visée\r\n    def toggle_visee():\r\n        if visee_auto.get():\r\n            bouton_visee.config(text=\"Visée automatique : Activée\")\r\n        else:\r\n            bouton_visee.config(text=\"Visée automatique : Désactivée\")\r\n            visee = 1\r\n\r\n    # Titre\r\n\r\n\r\n    # Bouton Visée Automatique\r\n    bouton_visee = Button(canevas, text=\"Visée automatique : Désactivée\",command=lambda: [visee_auto.set(not visee_auto.get()), toggle_visee()], bg=\"#322432\",fg=\"white\")\r\n    bouton_visee.place(x=300, y=80)\r\n\r\n\r\n\r\n\r\n    # Fonction pour créer des sliders\r\n    def ajouter_slider(label, var, min_val, max_val, pos_y):\r\n        Label(canevas, text=label, fg=\"white\", bg=\"#322432\").place(x=340, y=pos_y)\r\n        Scale(canevas, from_=min_val, to=max_val, orient=\"horizontal\", variable=var, length=300,\r\n        troughcolor=\"#553B6A\", fg=\"white\", bg=\"#322432\").place(x=250, y=pos_y + 30)\r\n\r\n    ajouter_slider(\"Niveau Sonore\", niveau_sonore, 0, 100, 200)\r\n    ajouter_slider(\"Points de Vie\", pv, 10, 1000, 280)\r\n    ajouter_slider(\"Nombre de tirs par joueur\", tirs_par_joueur, 1, 10, 360)\r\n    ajouter_slider(\"Dégâts par tir\", degats_par_tir, 10, 100, 440)\r\n\r\n    # Bouton OK\r\n    Button(canevas, text=\"OK\", command=canevas.destroy,bg=\"#322432\", fg=\"white\").place(x=380, y=520)\r\n\r\n    canevas.pack(pady=40)\r\n\r\n    return\r\ndef quitter():\r\n    if messagebox.askokcancel(\"Quitter\", \"Voulez-vous vraiment quitter ?\"):\r\n        fenetre.quit()\r\n\r\n\r\nfenetre = Tk()\r\n\r\n#permet l'expension de la page\r\nfenetre.resizable(True, True)\r\nfenetre.attributes('-fullscreen', True)\r\n\r\n#images de fond\r\nacceuil_temp = Image.open(\"fond_ecran.png\")\r\nfond_menu_temp= Image.open(\"fond_menu.png\")\r\n\r\ntaille_ecran =(1537,870)\r\ntaille_menu = (800,600)\r\n\r\nacceuil_nvl_taille = acceuil_temp.resize(taille_ecran , Image.Resampling.LANCZOS)\r\nfond_menu_nvl_taille=fond_menu_temp.resize(taille_menu , Image.Resampling.LANCZOS)\r\n\r\nacceuil = ImageTk.PhotoImage(acceuil_nvl_taille)\r\nfond_menu = ImageTk.PhotoImage(fond_menu_nvl_taille)\r\n\r\n\r\n\r\n\r\n#Images associées aux boutons\r\n\r\n#ouverture des images\r\nmenu_temp = Image.open(\"menu.png\")\r\nplay_temp = Image.open(\"play_final.png\")\r\nexit_temp = Image.open(\"quitter.png\")\r\ncroix_temp = Image.open(\"croix.png\")\r\ndebutant = Image.open(\"debutant.png\")\r\nintermediaire = Image.open(\"intermediaire.png\")\r\navance = Image.open(\"avance.png\")\r\n\r\n\r\n\r\n#taille des boutons\r\ntaillebt = (200, 100)\r\ntaille_icones =(20,20)\r\ntaillebt3=(150,75)\r\n\r\n#modification de la taille des boutons\r\nmenu_nvl_taille = menu_temp.resize(taillebt , Image.Resampling.LANCZOS)\r\nexit_nvl_taille = exit_temp.resize(taillebt, Image.Resampling.LANCZOS)\r\nplay_nvl_taille = play_temp.resize(taillebt)\r\ncroix_nvl_taille = croix_temp.resize(taille_icones)\r\n\r\ndebutant_nvl_taille = debutant.resize(taillebt3)\r\nintermediaire_nvl_taille = intermediaire.resize(taillebt3, Image.Resampling.LANCZOS)\r\navance_nvl_taille = avance.resize(taillebt3)\r\n\r\n#création de copies des images de taille différente\r\nexit_nvl_taille.save(\"exit_nvl_taille.png\")\r\nplay_nvl_taille.save(\"playn_nvltaille.png\")\r\nmenu_nvl_taille.save(\"menu_nvl_taille.png\")\r\ncroix_nvl_taille.save(\"croix_nvl_taille.png\")\r\n\r\ndebutant_nvl_taille.save(\"debutant_nvl_taille.png\")\r\nintermediaire_nvl_taille.save(\"intermediaire_nvl_taille.png\")\r\navance_nvl_taille.save(\"avance_nvl_taille.png\")\r\n\r\n# conversion des images pour permettre l'affichage\r\nexit = ImageTk.PhotoImage(exit_nvl_taille)\r\nplay = ImageTk.PhotoImage(play_nvl_taille)\r\nmenu = ImageTk.PhotoImage(menu_nvl_taille)\r\ncroix = ImageTk.PhotoImage(croix_nvl_taille)\r\n\r\ndebutant = ImageTk.PhotoImage(debutant_nvl_taille)\r\nintermediaire = ImageTk.PhotoImage(intermediaire_nvl_taille)\r\navance = ImageTk.PhotoImage(avance_nvl_taille)\r\n\r\n\r\nLabel_acceuil = Label(fenetre, image=acceuil)\r\nLabel_acceuil.place(relwidth=1, relheight=1)\r\n\r\n\r\n\r\n#Bas de page\r\nbouton_quitter = Button(fenetre, image=exit, borderwidth=0, highlightthickness=0,bg=\"#322432\", command=quitter)\r\nbouton_quitter.place(x=800, y = 762)\r\n\r\n\r\nbouton_menu = Button (fenetre, image=menu,borderwidth=0,highlightthickness=0, bg=\"#322432\", command=fctmenu)\r\nbouton_menu.place(x=550, y = 762)\r\n\r\n#Hauts de page\r\n\r\n\r\nbouton_intermediaire = Button(fenetre,image=intermediaire,borderwidth=0, highlightthickness=0,bg=\"#322432\", command= lancement1)\r\nbouton_intermediaire.place(x=650, y=570)\r\n\r\nbouton_avance = Button(fenetre,image=avance,borderwidth=0, highlightthickness=0,bg=\"#322432\", command=lancement2)\r\nbouton_avance.place(x=850, y=570)\r\n\r\nbouton_debutant = Button(fenetre,image=debutant,borderwidth=0, highlightthickness=0,bg=\"#322432\", command= lancement3)\r\nbouton_debutant.place(x=450, y=570)\r\n\r\n\r\n\r\n\r\nfenetre.mainloop()\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game.py b/game.py
--- a/game.py	(revision b47a00042bc72e64cb9c34aeb6ede0fea77ab8e9)
+++ b/game.py	(date 1746975033610)
@@ -17,7 +17,7 @@
 pseudos = []
 def lancement_pseudo(): #Fonction qui lance une page qui permet de récupérer les noms
 
-    pygame.init() # initialise pygame ( 2e fois pour sureté )
+    pygame.init() # initialise pygame
     info = pygame.display.Info() #récupérer les informations sur la taille de l'ecran de l'utilisateur
     WIDTH, HEIGHT = info.current_w, info.current_h #variables de largeur et de hauteur permettant d'adapter l'affichage à chaque utilisateur
 
@@ -36,7 +36,7 @@
     # Zone de saisie du pseudo ( rectangle blanc )
     input_box = pygame.Rect(525, 400, 300, 50)
     font = pygame.font.Font(None, 36)
-    texte = '' #initialise la variable texte qui sert à récupérer les pseudo
+    texte = '' #initialise la variable texte qui sert à récupérer
 
     joueur_num = 1 # variable de test (pour l'affichage des pages et pour la position du pseudo dans la liste)
 
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"CMakeSettings\">\r\n    <configurations />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"423e6d16-7e3f-48c9-a0e1-0cbe939c5061\" name=\"Changes\" comment=\"fond\">\r\n      <change afterPath=\"$PROJECT_DIR$/test.py\" afterDir=\"false\" />\r\n      <change afterPath=\"$PROJECT_DIR$/test3.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/exit_nvl_taille.png\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/exit_nvl_taille.png\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/game.py\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/game.py\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/menu.png\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/menu.png\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/menu_nvl_taille.png\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/menu_nvl_taille.png\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/ok.png\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/ok.png\" afterDir=\"false\" />\r\n      <change beforePath=\"$PROJECT_DIR$/quitter.png\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/quitter.png\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"ClangdSettings\">\r\n    <option name=\"formatViaClangd\" value=\"false\" />\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_BRANCH_BY_REPOSITORY\">\r\n      <map>\r\n        <entry key=\"$PROJECT_DIR$\" value=\"main\" />\r\n      </map>\r\n    </option>\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"GitHubPullRequestSearchHistory\">{\r\n  &quot;lastFilter&quot;: {\r\n    &quot;state&quot;: &quot;OPEN&quot;,\r\n    &quot;assignee&quot;: &quot;Anissa0MOHAMED&quot;\r\n  }\r\n}</component>\r\n  <component name=\"GithubPullRequestsUISettings\">{\r\n  &quot;selectedUrlAndAccountId&quot;: {\r\n    &quot;url&quot;: &quot;https://github.com/Anissa0MOHAMED/PROJET-TRANSVERSE-COLSON-MOHAMED-MOUFFOK-SOLLIER-TASSART&quot;,\r\n    &quot;accountId&quot;: &quot;068d223f-f398-451e-8d82-ad19cc08e1a2&quot;\r\n  }\r\n}</component>\r\n  <component name=\"InvalidFacetManager\">\r\n    <ignored-facets>\r\n      <facet id=\"PROJET-TRANSVERSE-COLSON-MOHAMED-MOUFFOK-SOLLIER-TASSART/invalid/Python facet\" />\r\n    </ignored-facets>\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 2\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2sWQvNeAIHRcU5Dk2vCmEj4grDM\" />\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"openDirectoriesWithSingleClick\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;Python.game.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.main.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.marche.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.test.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.test1.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.test2.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.test3.executor&quot;: &quot;Run&quot;,\r\n    &quot;Python.test4.executor&quot;: &quot;Run&quot;,\r\n    &quot;RunOnceActivity.RadMigrateCodeStyle&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.cidr.known.project.marker&quot;: &quot;true&quot;,\r\n    &quot;RunOnceActivity.readMode.enableVisualFormatting&quot;: &quot;true&quot;,\r\n    &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,\r\n    &quot;cidr.known.project.marker&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;AnissaM&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;\r\n  }\r\n}</component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-js-predefined-d6986cc7102b-5c90d61e3bab-JavaScript-PY-242.23726.102\" />\r\n        <option value=\"bundled-python-sdk-5e1850174b45-399fe30bd8c1-com.jetbrains.pycharm.pro.sharedIndexes.bundled-PY-242.23726.102\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"423e6d16-7e3f-48c9-a0e1-0cbe939c5061\" name=\"Changes\" comment=\"\" />\r\n      <created>1738569084323</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1738569084323</updated>\r\n      <workItem from=\"1738569085620\" duration=\"1612000\" />\r\n      <workItem from=\"1738914236224\" duration=\"19000\" />\r\n      <workItem from=\"1739196312318\" duration=\"1037000\" />\r\n      <workItem from=\"1739197367974\" duration=\"2192000\" />\r\n      <workItem from=\"1739261520976\" duration=\"1224000\" />\r\n      <workItem from=\"1740987180583\" duration=\"3011000\" />\r\n      <workItem from=\"1741336510084\" duration=\"17000\" />\r\n      <workItem from=\"1742199317494\" duration=\"7347000\" />\r\n      <workItem from=\"1743414238359\" duration=\"2109000\" />\r\n      <workItem from=\"1744009000929\" duration=\"1806000\" />\r\n      <workItem from=\"1744010898312\" duration=\"14519000\" />\r\n      <workItem from=\"1744031100746\" duration=\"3335000\" />\r\n      <workItem from=\"1744292823784\" duration=\"439000\" />\r\n      <workItem from=\"1744351445648\" duration=\"4111000\" />\r\n      <workItem from=\"1744986164461\" duration=\"6021000\" />\r\n      <workItem from=\"1746455695769\" duration=\"5569000\" />\r\n      <workItem from=\"1746465094106\" duration=\"3663000\" />\r\n      <workItem from=\"1746520271112\" duration=\"64000\" />\r\n      <workItem from=\"1746774136301\" duration=\"5430000\" />\r\n      <workItem from=\"1746783081604\" duration=\"6482000\" />\r\n      <workItem from=\"1746886411383\" duration=\"39394000\" />\r\n      <workItem from=\"1746953074860\" duration=\"17909000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"images\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744009735577</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744009735577</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"images\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744034669075</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744034669075</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"fond\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744359055180</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744359055180</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"fond\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744991426639</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744991426639</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"5\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.History.Properties\">\r\n    <option name=\"COLUMN_ID_ORDER\">\r\n      <list>\r\n        <option value=\"Default.Root\" />\r\n        <option value=\"Default.Author\" />\r\n        <option value=\"Default.Date\" />\r\n        <option value=\"Default.Subject\" />\r\n        <option value=\"GitHub.CommitStatus\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"images\" />\r\n    <MESSAGE value=\"Revert &quot;fond&quot;&#10;&#10;This reverts commit 6205b7aa49e5eff7541ad9b18b49dabe872fe15f.\" />\r\n    <MESSAGE value=\"fond\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"fond\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" suspend=\"THREAD\" type=\"python-line\">\r\n          <url>file://$PROJECT_DIR$/test.py</url>\r\n          <line>20</line>\r\n          <option name=\"timeStamp\" value=\"7\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n  <component name=\"com.intellij.coverage.CoverageDataManagerImpl\">\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test3.coverage\" NAME=\"test3 Coverage Results\" MODIFIED=\"1746909896616\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$main.coverage\" NAME=\"main Coverage Results\" MODIFIED=\"1738573050933\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$marche.coverage\" NAME=\"marche Coverage Results\" MODIFIED=\"1746931979806\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test.coverage\" NAME=\"test Coverage Results\" MODIFIED=\"1746956978175\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test4.coverage\" NAME=\"test4 Coverage Results\" MODIFIED=\"1746916097512\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test1.coverage\" NAME=\"test1 Coverage Results\" MODIFIED=\"1744027189372\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test2.coverage\" NAME=\"test2 Coverage Results\" MODIFIED=\"1746932060406\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n    <SUITE FILE_PATH=\"coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$game.coverage\" NAME=\"game Coverage Results\" MODIFIED=\"1746971229913\" SOURCE_PROVIDER=\"com.intellij.coverage.DefaultCoverageFileProvider\" RUNNER=\"coverage.py\" COVERAGE_BY_TEST_ENABLED=\"false\" COVERAGE_TRACING_ENABLED=\"false\" WORKING_DIRECTORY=\"$PROJECT_DIR$\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision b47a00042bc72e64cb9c34aeb6ede0fea77ab8e9)
+++ b/.idea/workspace.xml	(date 1746975033610)
@@ -7,17 +7,7 @@
     <configurations />
   </component>
   <component name="ChangeListManager">
-    <list default="true" id="423e6d16-7e3f-48c9-a0e1-0cbe939c5061" name="Changes" comment="fond">
-      <change afterPath="$PROJECT_DIR$/test.py" afterDir="false" />
-      <change afterPath="$PROJECT_DIR$/test3.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/exit_nvl_taille.png" beforeDir="false" afterPath="$PROJECT_DIR$/exit_nvl_taille.png" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/game.py" beforeDir="false" afterPath="$PROJECT_DIR$/game.py" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/menu.png" beforeDir="false" afterPath="$PROJECT_DIR$/menu.png" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/menu_nvl_taille.png" beforeDir="false" afterPath="$PROJECT_DIR$/menu_nvl_taille.png" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/ok.png" beforeDir="false" afterPath="$PROJECT_DIR$/ok.png" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/quitter.png" beforeDir="false" afterPath="$PROJECT_DIR$/quitter.png" afterDir="false" />
-    </list>
+    <list default="true" id="423e6d16-7e3f-48c9-a0e1-0cbe939c5061" name="Changes" comment="correction beug" />
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
     <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
@@ -29,7 +19,7 @@
   <component name="Git.Settings">
     <option name="RECENT_BRANCH_BY_REPOSITORY">
       <map>
-        <entry key="$PROJECT_DIR$" value="main" />
+        <entry key="$PROJECT_DIR$" value="AnissaM" />
       </map>
     </option>
     <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$" />
@@ -55,36 +45,38 @@
   &quot;associatedIndex&quot;: 2
 }</component>
   <component name="ProjectId" id="2sWQvNeAIHRcU5Dk2vCmEj4grDM" />
+  <component name="ProjectLevelVcsManager">
+    <ConfirmationsSetting value="1" id="Add" />
+  </component>
   <component name="ProjectViewState">
     <option name="hideEmptyMiddlePackages" value="true" />
     <option name="openDirectoriesWithSingleClick" value="true" />
     <option name="showLibraryContents" value="true" />
   </component>
-  <component name="PropertiesComponent">{
-  &quot;keyToString&quot;: {
-    &quot;Python.game.executor&quot;: &quot;Run&quot;,
-    &quot;Python.main.executor&quot;: &quot;Run&quot;,
-    &quot;Python.marche.executor&quot;: &quot;Run&quot;,
-    &quot;Python.test.executor&quot;: &quot;Run&quot;,
-    &quot;Python.test1.executor&quot;: &quot;Run&quot;,
-    &quot;Python.test2.executor&quot;: &quot;Run&quot;,
-    &quot;Python.test3.executor&quot;: &quot;Run&quot;,
-    &quot;Python.test4.executor&quot;: &quot;Run&quot;,
-    &quot;RunOnceActivity.RadMigrateCodeStyle&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.cidr.known.project.marker&quot;: &quot;true&quot;,
-    &quot;RunOnceActivity.readMode.enableVisualFormatting&quot;: &quot;true&quot;,
-    &quot;cf.first.check.clang-format&quot;: &quot;false&quot;,
-    &quot;cidr.known.project.marker&quot;: &quot;true&quot;,
-    &quot;git-widget-placeholder&quot;: &quot;AnissaM&quot;,
-    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,
-    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,
-    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,
-    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,
-    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,
-    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;
+  <component name="PropertiesComponent"><![CDATA[{
+  "keyToString": {
+    "Python.game.executor": "Run",
+    "Python.main.executor": "Run",
+    "Python.marche.executor": "Run",
+    "Python.test.executor": "Run",
+    "Python.test1.executor": "Run",
+    "Python.test2.executor": "Run",
+    "Python.test3.executor": "Run",
+    "Python.test4.executor": "Run",
+    "RunOnceActivity.RadMigrateCodeStyle": "true",
+    "RunOnceActivity.ShowReadmeOnStart": "true",
+    "RunOnceActivity.cidr.known.project.marker": "true",
+    "RunOnceActivity.readMode.enableVisualFormatting": "true",
+    "cf.first.check.clang-format": "false",
+    "cidr.known.project.marker": "true",
+    "node.js.detected.package.eslint": "true",
+    "node.js.detected.package.tslint": "true",
+    "node.js.selected.package.eslint": "(autodetect)",
+    "node.js.selected.package.tslint": "(autodetect)",
+    "nodejs_package_manager_path": "npm",
+    "vue.rearranger.settings.migration": "true"
   }
-}</component>
+}]]></component>
   <component name="SharedIndexes">
     <attachedChunks>
       <set>
@@ -156,7 +148,23 @@
       <option name="project" value="LOCAL" />
       <updated>1744991426639</updated>
     </task>
-    <option name="localTasksCounter" value="5" />
+    <task id="LOCAL-00005" summary="images">
+      <option name="closed" value="true" />
+      <created>1746973234078</created>
+      <option name="number" value="00005" />
+      <option name="presentableId" value="LOCAL-00005" />
+      <option name="project" value="LOCAL" />
+      <updated>1746973234078</updated>
+    </task>
+    <task id="LOCAL-00006" summary="correction beug">
+      <option name="closed" value="true" />
+      <created>1746974638191</created>
+      <option name="number" value="00006" />
+      <option name="presentableId" value="LOCAL-00006" />
+      <option name="project" value="LOCAL" />
+      <updated>1746974638191</updated>
+    </task>
+    <option name="localTasksCounter" value="7" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -185,10 +193,11 @@
     </option>
   </component>
   <component name="VcsManagerConfiguration">
-    <MESSAGE value="images" />
     <MESSAGE value="Revert &quot;fond&quot;&#10;&#10;This reverts commit 6205b7aa49e5eff7541ad9b18b49dabe872fe15f." />
     <MESSAGE value="fond" />
-    <option name="LAST_COMMIT_MESSAGE" value="fond" />
+    <MESSAGE value="images" />
+    <MESSAGE value="correction beug" />
+    <option name="LAST_COMMIT_MESSAGE" value="correction beug" />
   </component>
   <component name="XDebuggerManager">
     <breakpoint-manager>
@@ -204,11 +213,11 @@
   <component name="com.intellij.coverage.CoverageDataManagerImpl">
     <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test3.coverage" NAME="test3 Coverage Results" MODIFIED="1746909896616" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$main.coverage" NAME="main Coverage Results" MODIFIED="1738573050933" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$marche.coverage" NAME="marche Coverage Results" MODIFIED="1746931979806" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test.coverage" NAME="test Coverage Results" MODIFIED="1746956978175" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test.coverage" NAME="test Coverage Results" MODIFIED="1746973303651" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$marche.coverage" NAME="marche Coverage Results" MODIFIED="1746974250990" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test4.coverage" NAME="test4 Coverage Results" MODIFIED="1746916097512" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test1.coverage" NAME="test1 Coverage Results" MODIFIED="1744027189372" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
     <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$test2.coverage" NAME="test2 Coverage Results" MODIFIED="1746932060406" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
-    <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$game.coverage" NAME="game Coverage Results" MODIFIED="1746971229913" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
+    <SUITE FILE_PATH="coverage/PROJET_TRANSVERSE_COLSON_MOHAMED_MOUFFOK_SOLLIER_TASSART$game.coverage" NAME="game Coverage Results" MODIFIED="1746974407408" SOURCE_PROVIDER="com.intellij.coverage.DefaultCoverageFileProvider" RUNNER="coverage.py" COVERAGE_BY_TEST_ENABLED="false" COVERAGE_TRACING_ENABLED="false" WORKING_DIRECTORY="$PROJECT_DIR$" />
   </component>
 </project>
\ No newline at end of file
